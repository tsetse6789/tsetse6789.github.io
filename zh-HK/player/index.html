<!DOCTYPE html>
<html lang="zh-hk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-title" content="YTæ’­æ”¾å™¨">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" sizes="180x180" href="https://tsetse6789.github.io/player/YT-Player-iOS-Default.png">
    <title>YouTubeæ’­æ”¾å™¨</title>
    <link rel="icon" href="https://tsetse6789.github.io/player/ic_launcher-playstore.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE'
                    }
                }
            }
        }
    </script>
    <style>
        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .playlist-item {
            transition: all 0.2s ease;
        }

        .playlist-item:hover {
            transform: translateX(4px);
        }

        .playlist-item.active {
            background: rgba(93, 92, 222, 0.1);
            border-left: 3px solid #5D5CDE;
        }

        .ad-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            border-radius: 0.5rem;
            backdrop-filter: blur(10px);
        }

        .ad-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #5D5CDE;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Video Details Drawer Styles */
        .video-details-drawer {
            margin-top: 1rem;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .dark .video-details-drawer {
            background: rgba(55, 65, 81, 0.95);
        }

        .drawer-header {
            padding: 1rem;
            background: rgba(249, 250, 251, 0.8);
            border-bottom: 1px solid rgba(229, 231, 235, 0.5);
            backdrop-filter: blur(10px);
        }

        .dark .drawer-header {
            background: rgba(31, 41, 55, 0.8);
            border-bottom: 1px solid rgba(75, 85, 99, 0.5);
        }

        .drawer-handle {
            width: 2rem;
            height: 0.25rem;
            background: rgba(156, 163, 175, 0.6);
            border-radius: 9999px;
            transition: background-color 0.2s;
        }

        .drawer-header:hover .drawer-handle {
            background: rgba(107, 114, 128, 0.8);
        }

        .drawer-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .video-details-drawer.open .drawer-content {
            max-height: 600px;
            overflow-y: auto;
        }

        .video-details-drawer.open .drawer-toggle-icon svg {
            transform: rotate(180deg);
        }

        .line-clamp-4 {
            display: -webkit-box;
            -webkit-line-clamp: 4;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .stat-item {
            transition: transform 0.2s ease;
        }

        .stat-item:hover {
            transform: translateY(-2px);
        }

        .description-content.expanded .line-clamp-4 {
            -webkit-line-clamp: unset;
            display: block;
        }

        /* Playlist Action Buttons */
        .playlist-actions {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }

        .playlist-action-btn {
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            border-radius: 0.25rem;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            color: white;
        }

        .playlist-action-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .btn-rename {
            background: #3b82f6;
        }

        .btn-rename:hover {
            background: #2563eb;
        }

        .btn-duplicate {
            background: #10b981;
        }

        .btn-duplicate:hover {
            background: #059669;
        }

        .btn-merge {
            background: #f59e0b;
        }

        .btn-merge:hover {
            background: #d97706;
        }

        .btn-info {
            background: #6b7280;
        }

        .btn-info:hover {
            background: #4b5563;
        }

        /* Drag and Drop Styles */
        .playlist-video-item {
            transition: all 0.2s ease;
            cursor: grab;
            /* Disable text selection for touch devices */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Disable touch callouts on iOS */
            -webkit-touch-callout: none;
            /* Disable text selection highlighting */
            -webkit-tap-highlight-color: transparent;
        }

        .playlist-video-item:active {
            cursor: grabbing;
        }

        .playlist-video-item.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
        }

        .playlist-video-item.drag-over {
            border-top: 3px solid #5D5CDE;
            margin-top: 6px;
        }

        /* Touch feedback for mobile */
        .playlist-video-item.touch-active {
            background-color: rgba(93, 92, 222, 0.2);
            transform: scale(0.98);
        }

        /* Prevent text selection on playlist items */
        .playlist-item * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Selection Mode Styles */
        .selection-mode .playlist-video-item {
            cursor: default;
        }

        .video-checkbox {
            margin-right: 0.75rem;
        }

        .selection-controls {
            padding: 1rem;
            background: #f3f4f6;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            border: 2px dashed #9ca3af;
        }

        .dark .selection-controls {
            background: #4b5563;
            border-color: #6b7280;
        }

        /* Rename Form Styles */
        .rename-form {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            z-index: 10000;
            min-width: 300px;
            max-width: min(500px, 90vw);
            width: 100%;
        }

        @media (max-width: 640px) {
            .rename-form {
                min-width: calc(100vw - 32px);
                max-width: calc(100vw - 32px);
                margin: 16px;
                padding: 1rem;
            }
        }

        .dark .rename-form {
            background: #374151;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
        }

        /* Queue FAB and Panel Styles */
        .queue-fab {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 56px;
            height: 56px;
            background: #03DAC5;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
            border: none;
            color: white;
            font-size: 20px;
        }

        .queue-fab:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .queue-fab.has-queue {
            background: #10b981;
        }

        .queue-panel {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: min(380px, calc(100vw - 48px));
            max-height: 60vh;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            z-index: 1001;
            display: none;
            flex-direction: column;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 480px) {
            .queue-panel {
                width: calc(100vw - 32px);
                right: 16px;
                bottom: 16px;
                max-height: 70vh;
            }
        }

        .dark .queue-panel {
            background: #374151;
        }

        .queue-panel.open {
            display: flex;
            animation: slideInUp 0.3s ease;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(100px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .queue-header {
            padding: 16px 20px;
            border-bottom: 1px solid rgba(229, 231, 235, 0.5);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(249, 250, 251, 0.8);
            backdrop-filter: blur(10px);
        }

        .queue-selection-controls {
            padding: 12px 16px;
            background: #f3f4f6;
            border-bottom: 1px solid rgba(229, 231, 235, 0.5);
            border-radius: 0;
        }

        .dark .queue-selection-controls {
            background: #4b5563;
            border-bottom: 1px solid rgba(75, 85, 99, 0.5);
        }

        .queue-item.selection-mode {
            cursor: default;
        }

        .queue-checkbox {
            margin-right: 8px;
        }

        .dark .queue-header {
            background: rgba(31, 41, 55, 0.8);
            border-bottom: 1px solid rgba(75, 85, 99, 0.5);
        }

        .queue-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            min-height: 200px;
            max-height: calc(60vh - 80px);
        }

        .queue-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px;
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
            cursor: grab;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(229, 231, 235, 0.3);
        }

        .dark .queue-item {
            background: rgba(55, 65, 81, 0.8);
            border: 1px solid rgba(75, 85, 99, 0.3);
        }

        .queue-item:hover {
            background: rgba(93, 92, 222, 0.1);
            transform: translateX(4px);
        }

        .queue-item.active {
            background: rgba(93, 92, 222, 0.2);
            border-color: #5D5CDE;
        }

        .queue-item.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
            cursor: grabbing;
        }

        .queue-item.drag-over {
            border-top: 3px solid #5D5CDE;
            margin-top: 6px;
        }

        .queue-thumbnail {
            width: 48px;
            height: 36px;
            object-fit: cover;
            border-radius: 4px;
            flex-shrink: 0;
        }

        .queue-info {
            flex: 1;
            min-width: 0;
        }

        .queue-title {
            font-size: 0.875rem;
            font-weight: 500;
            line-height: 1.2;
            margin-bottom: 2px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .queue-channel {
            font-size: 0.75rem;
            color: #6b7280;
            line-height: 1;
        }

        .dark .queue-channel {
            color: #9ca3af;
        }

        .queue-actions {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .queue-btn {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s ease;
            background: rgba(107, 114, 128, 0.2);
            color: #4b5563;
        }

        .dark .queue-btn {
            background: rgba(156, 163, 175, 0.2);
            color: #9ca3af;
        }

        .queue-btn:hover {
            background: rgba(107, 114, 128, 0.3);
            transform: scale(1.1);
        }

        .queue-btn.play {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .queue-btn.remove {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .queue-empty {
            text-align: center;
            padding: 40px 20px;
            color: #6b7280;
        }

        .dark .queue-empty {
            color: #9ca3af;
        }

        .queue-count {
            position: absolute;
            top: -4px;
            right: -4px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 10px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
        }

        .dark .queue-count {
            border-color: #374151;
        }

        /* Play Options Dialog Styles */
        .play-options-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            z-index: 10000;
            min-width: 320px;
            max-width: 90vw;
        }

        .dark .play-options-dialog {
            background: #374151;
        }

        .play-option-btn {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: white;
            color: #374151;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .dark .play-option-btn {
            background: #4b5563;
            border-color: #6b7280;
            color: #f9fafb;
        }

        .play-option-btn:hover {
            background: #f3f4f6;
            border-color: #5D5CDE;
            transform: translateY(-1px);
        }

        .dark .play-option-btn:hover {
            background: #6b7280;
        }

        .play-option-icon {
            font-size: 1.25rem;
            width: 24px;
            text-align: center;
        }

        .play-option-content {
            flex: 1;
        }

        .play-option-title {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .play-option-desc {
            font-size: 0.875rem;
            color: #6b7280;
        }

        .dark .play-option-desc {
            color: #9ca3af;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen">
    <div class="container mx-auto px-4 py-6 max-w-7xl">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-primary mb-2">YouTubeæ’­æ”¾å™¨</h1>
            <p class="text-gray-600 dark:text-gray-400">ç”±Nutè£½ä½œ</p>
        </div>

        <div class="flex flex-col lg:flex-row gap-6">
            <!-- Main Content Area -->
            <div class="flex-1">
                <!-- Video Player Section -->
                <div id="videoContainer" class="hidden fade-in mb-6">
                    <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-4 shadow-sm">
                        <div class="flex justify-between items-start mb-4">
                            <div>
                                <h3 class="text-lg font-semibold mb-1" id="videoTitle">æ­£åœ¨æ’­æ”¾ï¼š</h3>
                                <p class="text-sm text-gray-600 dark:text-gray-400" id="videoChannel"></p>
                            </div>
                            <button 
                                onclick="clearVideo()" 
                                class="px-3 py-1 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors text-sm"
                            >
                                âœ•
                            </button>
                        </div>
                        
                        <!-- Playback Controls -->
                        <div class="mb-4">
                            <!-- First Row: Shuffle and Repeat -->
                            <div class="flex flex-wrap gap-3 mb-3">
                                <button 
                                    onclick="toggleShuffle()" 
                                    id="shuffleBtn"
                                    class="px-3 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors text-sm flex items-center gap-2"
                                >
                                    ğŸ”€ éš¨æ©Ÿæ’­æ”¾: <span id="shuffleStatus">é—œé–‰</span>
                                </button>
                                <button 
                                    onclick="toggleRepeat()" 
                                    id="repeatBtn"
                                    class="px-3 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors text-sm flex items-center gap-2"
                                >
                                    ğŸ” å¾ªç’°æ’­æ”¾: <span id="repeatStatus">é—œé–‰</span>
                                </button>
                            </div>
                            
                            <!-- Second Row: Navigation and Actions -->
                            <div class="flex flex-wrap gap-3">
                                <button 
                                    onclick="playPrevious()" 
                                    class="px-3 py-2 bg-primary text-white rounded hover:bg-opacity-90 transition-colors text-sm"
                                >
                                    â®ï¸
                                </button>
                                <button 
                                    onclick="playNext()" 
                                    class="px-3 py-2 bg-primary text-white rounded hover:bg-opacity-90 transition-colors text-sm"
                                >
                                    â­ï¸
                                </button>
                                <button 
                                    onclick="addCurrentVideoToPlaylist()" 
                                    class="px-3 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition-colors text-sm"
                                >
                                    â• æ·»åŠ 
                                </button>
                                <button 
                                    onclick="shareCurrentVideo()" 
                                    class="px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors text-sm"
                                >
                                    ğŸ“¤ åˆ†äº«
                                </button>
                            </div>
                        </div>

                        <div class="relative w-full" style="padding-bottom: 56.25%; /* 16:9 aspect ratio */">
                            <div id="videoPlayer" class="absolute top-0 left-0 w-full h-full rounded-lg"></div>
                            <!-- Ad Overlay -->
                            <div id="adOverlay" class="ad-overlay hidden">
                                <div class="spinner"></div>
                                <div class="text-white text-lg font-medium mt-4">è«‹ç¨å¾…Â·Â·Â·</div>
                                <div class="text-white text-sm opacity-75 mt-2">æ­£åœ¨åŠ è¼‰å½±ç‰‡å…§å®¹</div>
                            </div>
                        </div>

                        <!-- Video Details Drawer -->
                        <div id="videoDetailsDrawer" class="video-details-drawer">
                            <!-- Drawer Header -->
                            <div class="drawer-header" onclick="toggleVideoDetails()">
                                <div class="flex items-center justify-between w-full cursor-pointer">
                                    <div class="flex items-center gap-3">
                                        <div class="drawer-handle"></div>
                                        <span class="text-sm font-medium text-gray-700 dark:text-gray-300">å½±ç‰‡è³‡è¨Š</span>
                                    </div>
                                    <div class="drawer-toggle-icon">
                                        <svg class="w-5 h-5 text-gray-500 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                        </svg>
                                    </div>
                                </div>
                            </div>

                            <!-- Drawer Content -->
                            <div class="drawer-content">
                                <!-- Loading State -->
                                <div id="videoDetailsLoading" class="hidden p-4 text-center">
                                    <div class="animate-spin inline-block w-6 h-6 border-2 border-current border-t-transparent text-primary rounded-full"></div>
                                    <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">æ­£åœ¨åŠ è¼‰å½±ç‰‡è³‡è¨ŠÂ·Â·Â·</p>
                                </div>

                                <!-- Video Statistics -->
                                <div id="videoStats" class="hidden p-4 border-b border-gray-200 dark:border-gray-600">
                                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                                        <div class="stat-item">
                                            <div class="text-lg font-semibold text-primary" id="viewCount">-</div>
                                            <div class="text-xs text-gray-600 dark:text-gray-400">è§€çœ‹æ¬¡æ•¸</div>
                                        </div>
                                        <div class="stat-item">
                                            <div class="text-lg font-semibold text-green-600" id="likeCount">-</div>
                                            <div class="text-xs text-gray-600 dark:text-gray-400">é»è´Š</div>
                                        </div>
                                        <div class="stat-item">
                                            <div class="text-lg font-semibold text-blue-600" id="commentCount">-</div>
                                            <div class="text-xs text-gray-600 dark:text-gray-400">è©•è«–</div>
                                        </div>
                                        <div class="stat-item">
                                            <div class="text-lg font-semibold text-gray-600 dark:text-gray-400" id="publishedDate">-</div>
                                            <div class="text-xs text-gray-600 dark:text-gray-400">ç™¼å¸ƒæ—¥æœŸ</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Video Description -->
                                <div id="videoDescription" class="hidden p-4">
                                    <h4 class="font-semibold mb-3 text-gray-900 dark:text-white">æè¿°</h4>
                                    <div class="description-content">
                                        <div id="descriptionText" class="text-sm text-gray-700 dark:text-gray-300 whitespace-pre-wrap line-clamp-4 mb-3"></div>
                                        <button id="expandDescription" class="text-primary hover:text-opacity-80 text-sm font-medium hidden">
                                            é¡¯ç¤ºæ›´å¤š
                                        </button>
                                    </div>
                                </div>

                                <!-- Channel Info -->
                                <div id="channelInfo" class="hidden p-4 border-t border-gray-200 dark:border-gray-600">
                                    <div class="flex items-center gap-3">
                                        <img id="channelThumbnail" src="" alt="Channel" class="w-12 h-12 rounded-full object-cover">
                                        <div class="flex-1">
                                            <div class="font-medium text-gray-900 dark:text-white" id="channelTitle"></div>
                                            <div class="text-sm text-gray-600 dark:text-gray-400" id="subscriberCount"></div>
                                        </div>
                                        <button 
                                            onclick="viewChannelFromDetails()" 
                                            class="px-3 py-1 bg-primary text-white rounded hover:bg-opacity-90 transition-colors text-sm"
                                        >
                                            ç€è¦½é »é“
                                        </button>
                                    </div>
                                </div>

                                <!-- Error State -->
                                <div id="videoDetailsError" class="hidden p-4 text-center">
                                    <p class="text-sm text-gray-600 dark:text-gray-400">ç„¡æ³•åŠ è¼‰å½±ç‰‡å…§å®¹</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- YouTube Search Section -->
                <div id="searchSection" class="bg-gray-50 dark:bg-gray-800 rounded-lg p-6 shadow-sm">
                    <h3 class="text-lg font-semibold mb-4">åœ¨YouTubeä¸­æœå°‹ï¼š</h3>
                    
                    <!-- Search Type Selector -->
                    <div class="flex gap-2 mb-4">
                        <button 
                            onclick="setSearchType('video')" 
                            id="videoSearchBtn"
                            class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-opacity-90 transition-colors font-medium"
                        >
                            ğŸ“º å½±ç‰‡
                        </button>
                        <button 
                            onclick="setSearchType('channel')" 
                            id="channelSearchBtn"
                            class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors font-medium"
                        >
                            ğŸ‘¤ é »é“
                        </button>
                    </div>
                    
                    <!-- Navigation Breadcrumb -->
                    <div id="navigationBar" class="hidden mb-4 p-3 bg-blue-50 dark:bg-blue-900 rounded-lg">
                        <div class="flex items-center gap-2 text-sm">
                            <button 
                                onclick="navigateUp()" 
                                id="upButton"
                                class="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors flex items-center gap-1"
                            >
                                â¬†ï¸ è¿”å›
                            </button>
                            <span class="text-gray-600 dark:text-gray-300" id="navigationPath">æœå°‹çµæœ</span>
                        </div>
                    </div>
                    
                    <div class="flex flex-col sm:flex-row gap-3 mb-6">
                        <input 
                            type="text" 
                            id="searchInput" 
                            placeholder="åœ¨YouTubeä¸­æœå°‹æˆ–è²¼ä¸Šé€£çµ"
                            class="flex-1 px-4 py-3 text-base border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                        >
                        <button 
                            onclick="performSearch()" 
                            id="searchButton"
                            class="px-6 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors font-medium"
                        >
                            ğŸ” æœç´¢
                        </button>
                        <button 
                            onclick="clearSearchResults()" 
                            id="clearButton"
                            class="px-4 py-3 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors font-medium"
                        >
                            âœ• æ¸…é™¤
                        </button>
                    </div>
                    
                    <!-- Loading State -->
                    <div id="loadingState" class="text-center py-8 hidden">
                        <div class="animate-spin inline-block w-8 h-8 border-4 border-current border-t-transparent text-primary rounded-full" role="status"></div>
                        <p class="mt-2 text-gray-600 dark:text-gray-400">æœå°‹ä¸­å½±ç‰‡Â·Â·Â·</p>
                    </div>
                    
                    <!-- Search Results -->
                    <div id="searchResults" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"></div>
                    
                    <!-- No Results -->
                    <div id="noResults" class="text-center py-8 hidden">
                        <p class="text-gray-600 dark:text-gray-400">æœªæ‰¾åˆ°ç›¸é—œå½±ç‰‡ã€‚è«‹å˜—è©¦å…¶ä»–æœå°‹è©ã€‚</p>
                    </div>
                </div>
            </div>

            <!-- Playlist Sidebar -->
            <div class="lg:w-80">
                <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-6 shadow-sm">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold">æ’­æ”¾æ¸…å–®</h3>
                        <div class="flex gap-2">
                            <button 
                                onclick="showImportPlaylistDialog()" 
                                class="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors text-sm"
                                title="Import playlist from file"
                            >
                                ğŸ“¥ åŒ¯å…¥
                            </button>
                            <button 
                                onclick="showCreatePlaylistForm()" 
                                class="px-3 py-1 bg-primary text-white rounded hover:bg-opacity-90 transition-colors text-sm"
                            >
                                â• æ–°å¢
                            </button>
                        </div>
                    </div>

                    <!-- Create Playlist Form -->
                    <div id="createPlaylistForm" class="hidden mb-4 p-4 bg-white dark:bg-gray-700 rounded-lg border">
                        <input 
                            type="text" 
                            id="playlistNameInput" 
                            placeholder="æ’­æ”¾æ¸…å–®åç¨±Â·Â·Â·"
                            class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded mb-3 bg-white dark:bg-gray-800 text-gray-900 dark:text-white"
                        >
                        <div class="flex gap-2">
                            <button 
                                onclick="createPlaylist()" 
                                class="px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700 transition-colors text-sm"
                            >
                                å»ºç«‹
                            </button>
                            <button 
                                onclick="hideCreatePlaylistForm()" 
                                class="px-3 py-1 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors text-sm"
                            >
                                å–æ¶ˆ
                            </button>
                        </div>
                    </div>

                    <!-- Playlists List -->
                    <div id="playlistsList" class="space-y-2">
                        <p class="text-gray-600 dark:text-gray-400 text-sm">é‚„æ²’æœ‰ä»»ä½•æ’­æ”¾æ¸…å–®ã€‚å»ºç«‹ä¸€å€‹é–‹å§‹å§ï¼</p>
                    </div>

                    <!-- Current Playlist -->
                    <div id="currentPlaylistSection" class="hidden mt-6">
                        <div class="flex justify-between items-center mb-3">
                            <h4 class="font-semibold" id="currentPlaylistTitle">ç›®å‰æ’­æ”¾æ¸…å–®</h4>
                            <div class="flex gap-2">
                                <button 
                                    id="playlistSelectButton"
                                    onclick="toggleSelectionMode()" 
                                    class="px-2 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors text-xs"
                                >
                                    é¸æ“‡
                                </button>
                                <button 
                                    onclick="clearCurrentPlaylist()" 
                                    class="text-gray-500 hover:text-red-500 transition-colors"
                                >
                                    âœ•
                                </button>
                            </div>
                        </div>
                        
                        <!-- Selection Controls -->
                        <div id="selectionControls" class="selection-controls hidden">
                            <div class="flex flex-wrap gap-2 text-sm">
                                <span class="font-medium text-gray-700 dark:text-gray-300">
                                    å·²é¸æ“‡ï¼š<span id="selectedCount">0</span>
                                </span>
                                <button onclick="selectAllVideos()" class="text-blue-600 hover:text-blue-800">å…¨é¸</button>
                                <button onclick="deselectAllVideos()" class="text-blue-600 hover:text-blue-800">å–æ¶ˆå…¨é¸</button>
                            </div>
                            <div class="flex flex-wrap gap-2 mt-2">
                                <button 
                                    onclick="addSelectedVideosToQueue()" 
                                    class="px-3 py-1 bg-primary text-white rounded hover:bg-opacity-90 transition-colors text-xs"
                                >
                                    ğŸµ æ·»åŠ è‡³æ’­æ”¾åˆ—è¡¨
                                </button>
                                <button 
                                    onclick="moveSelectedVideos()" 
                                    class="px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700 transition-colors text-xs"
                                >
                                    ğŸ“ ç§»å‹•
                                </button>
                                <button 
                                    onclick="copySelectedVideos()" 
                                    class="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors text-xs"
                                >
                                    ğŸ“‹ è¤‡è£½
                                </button>
                                <button 
                                    onclick="deleteSelectedVideos()" 
                                    class="px-3 py-1 bg-red-600 text-white rounded hover:bg-red-700 transition-colors text-xs"
                                >
                                    ğŸ—‘ï¸ åˆªé™¤
                                </button>
                            </div>
                        </div>
                        
                        <div id="currentPlaylistVideos" class="space-y-2 max-h-96 overflow-y-auto">
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Queue FAB -->
    <button id="queueFab" class="queue-fab" onclick="toggleQueuePanel()" title="Queue">
        <svg width="20" height="20" viewBox="0 0 32 32" fill="black" xmlns="http://www.w3.org/2000/svg">
            <path d="M12.022,23.997l-0.002,-0c-1.104,-0 -2.001,0.897 -2.001,2.001c-0,1.105 0.897,2.002 2.001,2.002c1.105,0 2.002,-0.897 2.002,-2.002l0,-7.122c0,-0 6.001,-0.75 6.001,-0.75l0.003,3.867c-1.105,0 -2.002,0.897 -2.002,2.002c-0,1.105 0.897,2.002 2.002,2.002c1.104,-0 2.001,-0.897 2.001,-2.002l-0.005,-7.003c-0,-0.286 -0.123,-0.559 -0.338,-0.749c-0.215,-0.189 -0.501,-0.278 -0.786,-0.242l-8,1c-0.5,0.062 -0.876,0.488 -0.876,0.992l0,6.004Z"/>
            <path d="M8.951,14.98c1.811,-1.82 4.318,-2.947 7.086,-2.947c2.755,0 5.251,1.117 7.06,2.921c0.391,0.39 1.025,0.39 1.414,-0.001c0.39,-0.391 0.389,-1.025 -0.001,-1.414c-2.171,-2.166 -5.167,-3.506 -8.473,-3.506c-3.322,0 -6.33,1.352 -8.503,3.536c-0.39,0.391 -0.388,1.025 0.003,1.414c0.391,0.389 1.025,0.388 1.414,-0.003Z"/>
            <path d="M4.975,10.074c2.972,-2.545 6.832,-4.083 11.048,-4.083c4.203,-0 8.052,1.528 11.02,4.059c0.42,0.358 1.051,0.308 1.409,-0.112c0.359,-0.42 0.308,-1.052 -0.112,-1.41c-3.317,-2.829 -7.619,-4.537 -12.317,-4.537c-4.713,-0 -9.027,1.719 -12.349,4.564c-0.419,0.359 -0.468,0.99 -0.109,1.41c0.359,0.419 0.991,0.468 1.41,0.109Z"/>
        </svg>
        <span id="queueCount" class="queue-count hidden">0</span>
    </button>

    <!-- Queue Panel -->
    <div id="queuePanel" class="queue-panel">
        <div class="queue-header">
            <div class="flex items-center gap-3">
                <span class="text-lg font-semibold text-gray-900 dark:text-white">æ’­æ”¾åˆ—è¡¨</span>
                <span id="queueStatusText" class="text-sm text-gray-600 dark:text-gray-400">æ²’æœ‰å½±ç‰‡</span>
            </div>
            <div class="flex items-center gap-2">
                <button 
                    id="queueSelectButton"
                    onclick="toggleQueueSelectionMode()" 
                    class="px-2 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors text-xs"
                >
                    é¸æ“‡
                </button>
                <button 
                    onclick="showImportQueueDialog()" 
                    class="px-2 py-1 bg-green-600 text-white rounded hover:bg-green-700 transition-colors text-xs"
                    title="Import queue to playlist"
                >
                    ğŸ“¥
                </button>
                <button onclick="closeQueuePanel()" class="text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 transition-colors text-xl">
                    âœ•
                </button>
            </div>
        </div>
        
        <!-- Queue Selection Controls -->
        <div id="queueSelectionControls" class="queue-selection-controls hidden">
            <div class="flex flex-wrap gap-2 text-sm">
                <span class="font-medium text-gray-700 dark:text-gray-300">
                    å·²é¸æ“‡ï¼š<span id="queueSelectedCount">0</span>
                </span>
                <button onclick="selectAllQueueVideos()" class="text-blue-600 hover:text-blue-800">å…¨é¸</button>
                <button onclick="deselectAllQueueVideos()" class="text-blue-600 hover:text-blue-800">å–æ¶ˆå…¨é¸</button>
            </div>
            <div class="flex flex-wrap gap-2 mt-2">
                <button 
                    onclick="deleteSelectedFromQueue()" 
                    class="px-3 py-1 bg-red-600 text-white rounded hover:bg-red-700 transition-colors text-xs"
                >
                    ğŸ—‘ï¸ åˆªé™¤é¸å–é …ç›®
                </button>
            </div>
        </div>
        
        <div class="queue-content">
            <div id="queueEmpty" class="queue-empty">
                <div class="text-4xl mb-3">ğŸµ</div>
                <div class="font-medium mb-1">æ’­æ”¾åˆ—è¡¨æ˜¯ç©ºçš„</div>
                <div class="text-sm">å¾æœå°‹çµæœæˆ–æ’­æ”¾æ¸…å–®æ·»åŠ å½±ç‰‡</div>
            </div>
            
            <div id="queueList" class="hidden">
                <!-- Queue items will be rendered here -->
            </div>
        </div>
    </div>

    <!-- YouTube Player API -->
    <script src="https://www.youtube.com/iframe_api"></script>
    
    <script>
        // YouTube Player API variables
        let player;
        let playerReady = false;
        let isAdPlaying = false;
        let playerMutedForAd = false;
        
        // Background playback variables
        let audioContext;
        let isPageVisible = true;
        let backgroundPlaybackEnabled = true;
        let wakeLock = null;
        let userPausedManually = false;
        let lastKnownPlaybackState = null;

        // YouTube Player API callback
        function onYouTubeIframeAPIReady() {
            console.log('YouTube API ready');
            playerReady = true;
        }

        // Player state change event handler
        function onPlayerStateChange(event) {
            console.log('Player state changed:', event.data);
            
            // Track manual pause/play actions
            if (event.data === YT.PlayerState.PAUSED) {
                // If user manually paused (not due to browser behavior)
                if (isPageVisible) {
                    userPausedManually = true;
                    console.log('User manually paused');
                } else {
                    console.log('Browser auto-paused (background)');
                }
            } else if (event.data === YT.PlayerState.PLAYING) {
                // Reset manual pause flag when playing
                userPausedManually = false;
                console.log('Video playing');
            }
            
            // Store the current playback state
            lastKnownPlaybackState = event.data;
            
            // Update media session playback state
            updateMediaSessionPlaybackState(event.data);
            
            // YT.PlayerState.ENDED = 0
            if (event.data === YT.PlayerState.ENDED) {
                handleVideoEnd();
            }
            
            // Check for ads using getCurrentTime method
            // If getCurrentTime returns -1, it usually means an ad is playing
            checkForAds();
        }

        // Ad state change event handler
        function onAdStateChange(event) {
            // event.data: 1 = Ad Started, 2 = Ad Ended, others = other ad states
            if (event.data === 1) {
                // Ad started
                showAdOverlay();
            } else if (event.data === 2) {
                // Ad ended
                hideAdOverlay();
            }
        }

        // Enhanced ad detection and blocking
        function checkForAds() {
            if (!player) return;
            
            try {
                const currentTime = player.getCurrentTime();
                const duration = player.getDuration();
                const state = player.getPlayerState();
                
                let adDetected = false;
                
                // Method 1: Check for invalid/missing time data (common during ads)
                if (currentTime === -1 || currentTime === 0 && state === YT.PlayerState.PLAYING) {
                    adDetected = true;
                }
                
                // Method 2: Check for missing duration (ads often don't have proper duration)
                if (!duration || duration === 0) {
                    adDetected = true;
                }
                
                // Method 3: Check video URL for ad indicators
                try {
                    const videoUrl = player.getVideoUrl && player.getVideoUrl();
                    if (videoUrl && (videoUrl.includes('googleads') || videoUrl.includes('doubleclick') || videoUrl.includes('/ads/'))) {
                        adDetected = true;
                    }
                } catch (e) {
                    // URL check failed, might be an ad
                }
                
                // Method 4: Check for limited quality options (ads typically have fewer)
                try {
                    const qualities = player.getAvailableQualityLevels && player.getAvailableQualityLevels();
                    if (qualities && qualities.length <= 2 && currentTime <= 5) {
                        adDetected = true;
                    }
                } catch (e) {
                    // Quality check failed
                }
                
                // Method 5: Check player state inconsistencies
                if (state === YT.PlayerState.BUFFERING && currentTime <= 0) {
                    adDetected = true;
                }
                
                // Video is properly playing
                const videoIsPlaying = currentTime > 0 && duration > 0 && currentTime <= duration && 
                                     !adDetected && (state === YT.PlayerState.PLAYING || state === YT.PlayerState.PAUSED);
                
                if (adDetected && !isAdPlaying) {
                    console.log('Ad detected - hiding ads');
                    showAdOverlay();
                    // Try to skip ad automatically
                    trySkipAd();
                } else if (videoIsPlaying && isAdPlaying) {
                    console.log('Video content detected - showing video');
                    hideAdOverlay();
                }
                
            } catch (error) {
                console.log('Error in ad detection:', error);
                // On error, assume there might be an ad to be safe
                if (!isAdPlaying && player.getPlayerState && player.getPlayerState() !== YT.PlayerState.UNSTARTED) {
                    showAdOverlay();
                }
            }
        }
        
        // Attempt to skip ads automatically
        function trySkipAd() {
            if (!player) return;
            
            try {
                // Try to find and click skip button
                setTimeout(() => {
                    const skipButton = document.querySelector('.ytp-ad-skip-button, .ytp-skip-ad-button');
                    if (skipButton && skipButton.offsetParent !== null) {
                        console.log('Clicking skip button');
                        skipButton.click();
                    }
                }, 1000);
                
                // Try seeking to end of video if it's a short ad
                setTimeout(() => {
                    if (player.getDuration && player.seekTo) {
                        const duration = player.getDuration();
                        if (duration > 0 && duration < 30) { // Short ad
                            console.log('Seeking to end of short ad');
                            player.seekTo(duration - 1);
                        }
                    }
                }, 2000);
                
            } catch (error) {
                console.log('Error trying to skip ad:', error);
            }
        }

        // Show ad overlay and mute player
        function showAdOverlay() {
            isAdPlaying = true;
            const overlay = document.getElementById('adOverlay');
            overlay.classList.remove('hidden');
            
            // Mute the player during ads
            if (player && player.isMuted && player.mute) {
                if (!player.isMuted()) {
                    player.mute();
                    playerMutedForAd = true;
                }
            }
            
            // Maintain media session during ads with special metadata
            maintainMediaSessionDuringAds();
        }

        // Hide ad overlay and restore sound
        function hideAdOverlay() {
            isAdPlaying = false;
            const overlay = document.getElementById('adOverlay');
            overlay.classList.add('hidden');
            
            // Restore sound if we muted it for ads
            if (player && player.unMute && playerMutedForAd) {
                player.unMute();
                playerMutedForAd = false;
            }
            
            // Restore normal media session metadata
            restoreMediaSessionAfterAds();
        }

        // Maintain media session during ads to prevent browser from closing the player
        function maintainMediaSessionDuringAds() {
            if ('mediaSession' in navigator) {
                console.log('Maintaining media session during ads');
                
                // Set special ad metadata to keep session active
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: 'å»£å‘Š',
                    artist: 'è·³éä¸­',
                    album: 'YouTubeæ’­æ”¾å™¨',
                    artwork: [
                        { src: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSIjNUQ1Q0RFIi8+Cjx0ZXh0IHg9IjI1NiIgeT0iMjgwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSJ3aGl0ZSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjQ4IiBmb250LXdlaWdodD0iYm9sZCI+QWRzPC90ZXh0Pgo8L3N2Zz4K', sizes: '96x96', type: 'image/svg+xml' },
                        { src: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSIjNUQ1Q0RFIi8+Cjx0ZXh0IHg9IjI1NiIgeT0iMjgwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSJ3aGl0ZSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjQ4IiBmb250LXdlaWdodD0iYm9sZCI+QWRzPC90ZXh0Pgo8L3N2Zz4K', sizes: '128x128', type: 'image/svg+xml' },
                        { src: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSIjNUQ1Q0RFIi8+Cjx0ZXh0IHg9IjI1NiIgeT0iMjgwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSJ3aGl0ZSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjQ4IiBmb250LXdlaWdodD0iYm9sZCI+QWRzPC90ZXh0Pgo8L3N2Zz4K', sizes: '192x192', type: 'image/svg+xml' },
                        { src: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSIjNUQ1Q0RFIi8+Cjx0ZXh0IHg9IjI1NiIgeT0iMjgwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSJ3aGl0ZSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjQ4IiBmb250LXdlaWdodD0iYm9sZCI+QWRzPC90ZXh0Pgo8L3N2Zz4K', sizes: '256x256', type: 'image/svg+xml' },
                        { src: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSIjNUQ1Q0RFIi8+Cjx0ZXh0IHg9IjI1NiIgeT0iMjgwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSJ3aGl0ZSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjQ4IiBmb250LXdlaWdodD0iYm9sZCI+QWRzPC90ZXh0Pgo8L3N2Zz4K', sizes: '384x384', type: 'image/svg+xml' },
                        { src: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSIjNUQ1Q0RFIi8+Cjx0ZXh0IHg9IjI1NiIgeT0iMjgwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSJ3aGl0ZSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjQ4IiBmb250LXdlaWdodD0iYm9sZCI+QWRzPC90ZXh0Pgo8L3N2Zz4K', sizes: '512x512', type: 'image/svg+xml' }
                    ]
                });
                
                // Keep playback state as playing to prevent browser from stopping
                navigator.mediaSession.playbackState = 'playing';
                
                // Clear position state during ads to hide progress bar
                try {
                    navigator.mediaSession.setPositionState({});
                } catch (error) {
                    console.log('Error clearing position state during ads:', error);
                }
            }
        }

        // Restore normal media session after ads
        function restoreMediaSessionAfterAds() {
            if ('mediaSession' in navigator && currentVideoInfo.title) {
                console.log('Restoring media session after ads');
                
                // Restore the original video metadata
                updateMediaSessionMetadata(currentVideoInfo.title, currentVideoInfo.artist, currentVideoInfo.artwork);
                
                // Update playback state based on current player state
                if (player) {
                    try {
                        const state = player.getPlayerState();
                        updateMediaSessionPlaybackState(state);
                        
                        // Restore position state if video is playing
                        if (state === YT.PlayerState.PLAYING) {
                            setTimeout(() => {
                                updateMediaSessionPosition();
                            }, 1000); // Wait a bit for player to stabilize
                        }
                    } catch (error) {
                        console.log('Error restoring media session after ads:', error);
                    }
                }
            }
        }

        // Handle video end - auto advance to next video (updated for queue system)
        function handleVideoEnd() {
            // Use queue system if queue has videos
            if (playQueue.length > 0) {
                handleVideoEndWithQueue();
                return;
            }
            
            // Handle repeat all mode or normal playback
            let nextIndex;
            
            if (playbackSettings.shuffle) {
                // Shuffle mode: pick random video
                nextIndex = Math.floor(Math.random() * videos.length);
            } else {
                // Normal mode: next video in sequence
                nextIndex = currentVideoIndex + 1;
                
                // If at end of playlist
                if (nextIndex >= videos.length) {
                    if (playbackSettings.repeat === 'all') {
                        nextIndex = 0; // Loop back to start
                    } else {
                        return; // Stop playing
                    }
                }
            }
            
            // Auto-play next video
            playVideoFromPlaylist(nextIndex);
        }

        // Dark mode support
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Global variables
        let apiKey = 'AIzaSyCQExuj8PVT14tgxr9jUB7qGsG364P_u48';
        let playlists = {};
        let currentPlaylist = null;
        let currentVideoIndex = 0;
        let playbackSettings = {
            shuffle: false,
            repeat: 'é—œé–‰' // 'off', 'all', 'one'
        };
        let searchType = 'video'; // 'video' or 'channel'
        let currentChannelId = null;
        let navigationStack = [];
        
        // Queue System Variables
        let playQueue = [];
        let currentQueueIndex = 0;
        let isQueuePanelOpen = false;
        
        // Media Session variables
        let currentVideoInfo = {
            title: '',
            artist: '',
            artwork: ''
        };

        // LocalStorage utilities (much more reliable than cookies)
        function setLocalStorage(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
                return true;
            } catch (error) {
                console.error('Error saving to localStorage:', error);
                return false;
            }
        }

        function getLocalStorage(key) {
            try {
                const item = localStorage.getItem(key);
                return item ? JSON.parse(item) : null;
            } catch (error) {
                console.error('Error reading from localStorage:', error);
                return null;
            }
        }

        function removeLocalStorage(key) {
            try {
                localStorage.removeItem(key);
                return true;
            } catch (error) {
                console.error('Error removing from localStorage:', error);
                return false;
            }
        }

        // Initialize app
        window.addEventListener('DOMContentLoaded', function() {
            loadSettings();
            updatePlaybackUI();
            initializeBackgroundPlayback();
            
            // Check for URL parameter to auto-play video
            checkForAutoPlayURL();
            
            // Set up page unload warning for active queue
            setupQueueUnloadWarning();
        });

        // Queue unload warning
        function setupQueueUnloadWarning() {
            window.addEventListener('beforeunload', (event) => {
                // Only show warning if queue has videos
                if (playQueue.length > 0) {
                    const message = 'æ‚¨ç¢ºå®šè¦é›¢é–‹å—ï¼Ÿæ‚¨çš„æ’­æ”¾åˆ—è¡¨æœƒè¢«é‡ç½®ã€‚';
                    event.preventDefault();
                    event.returnValue = message;
                    return message;
                }
            });
        }

        // Load settings from localStorage
        function loadSettings() {
            const savedPlaylists = getLocalStorage('ytplayer_playlists');
            const savedPlaybackSettings = getLocalStorage('ytplayer_playback');
            const savedApiKey = getLocalStorage('ytplayer_apikey');

            if (savedPlaylists) {
                playlists = savedPlaylists;
                renderPlaylists();
                console.log(`Loaded ${Object.keys(playlists).length} playlists from storage`);
            }

            if (savedPlaybackSettings) {
                playbackSettings = savedPlaybackSettings;
            }

            if (savedApiKey) {
                apiKey = savedApiKey;
            }
        }

        // Save settings to localStorage
        function saveSettings() {
            const success = setLocalStorage('ytplayer_playlists', playlists);
            setLocalStorage('ytplayer_playback', playbackSettings);
            setLocalStorage('ytplayer_apikey', apiKey);
            
            if (success) {
                console.log(`Saved ${Object.keys(playlists).length} playlists to storage`);
            } else {
                console.error('Failed to save playlists to storage');
            }
        }



        // Search functionality
        function setSearchType(type) {
            searchType = type;
            currentChannelId = null;
            setSearchTypeUI(type);
            clearSearchResults();
        }

        function performSearch() {
            const searchInput = document.getElementById('searchInput');
            const query = searchInput.value.trim();
            
            // Check if the input is a URL
            if (isYouTubeURL(query)) {
                console.log('URL detected in search input:', query);
                handleURLFromSearch(query);
                return;
            }
            
            // Regular search functionality
            if (searchType === 'video') {
                searchVideos();
            } else {
                searchChannels();
            }
        }

        async function searchVideos(channelId = null) {
            const searchInput = document.getElementById('searchInput');
            const query = searchInput.value.trim();
            
            if (!query && !channelId) {
                alert('è«‹è¼¸å…¥æœå°‹è©');
                return;
            }
            
            if (!apiKey) {
                alert('è«‹å…ˆè¨­å®šæ‚¨çš„APIé‡‘é‘°');
                return;
            }
            
            showLoading();
            
            try {
                let url;
                if (channelId) {
                    url = `https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=50&channelId=${channelId}&type=video&order=relevance&key=${apiKey}`;
                } else {
                    url = `https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=50&q=${encodeURIComponent(query)}&type=video&key=${apiKey}`;
                }
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`APIéŒ¯èª¤ (${response.status})`);
                }
                
                const data = await response.json();
                displayVideoResults(data.items);
                
            } catch (error) {
                console.error('æœå°‹éŒ¯èª¤ï¼š', error);
                hideLoading();
                alert(`æœå°‹å¤±æ•—ï¼š${error.message}`);
            }
        }

        async function searchChannels() {
            const searchInput = document.getElementById('searchInput');
            const query = searchInput.value.trim();
            
            if (!query) {
                alert('è«‹è¼¸å…¥æœå°‹è©');
                return;
            }
            
            if (!apiKey) {
                alert('è«‹å…ˆè¨­å®šæ‚¨çš„APIé‡‘é‘°');
                return;
            }
            
            showLoading();
            
            try {
                const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=50&q=${encodeURIComponent(query)}&type=channel&key=${apiKey}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`APIéŒ¯èª¤ (${response.status})`);
                }
                
                const data = await response.json();
                displayChannelResults(data.items);
                
            } catch (error) {
                console.error('Search error:', error);
                hideLoading();
                alert(`æœå°‹å¤±æ•—ï¼š${error.message}`);
            }
        }

        function displayVideoResults(videos) {
            hideLoading();
            const resultsContainer = document.getElementById('searchResults');
            const noResultsDiv = document.getElementById('noResults');
            
            if (!videos || videos.length === 0) {
                resultsContainer.innerHTML = '';
                noResultsDiv.classList.remove('hidden');
                currentSearchData = null;
                return;
            }
            
            noResultsDiv.classList.add('hidden');
            
            // Store the current search data
            currentSearchData = {
                type: 'videos',
                data: videos,
                channelTitle: ''
            };
            
            resultsContainer.innerHTML = `
                <div class="col-span-full mb-4 text-center text-sm text-gray-600 dark:text-gray-400">
                    æ‰¾åˆ°äº† ${videos.length} æ¢å½±ç‰‡
                </div>
            ` + videos.map(video => `
                <div class="bg-white dark:bg-gray-700 rounded-lg shadow-md overflow-hidden">
                    <div class="relative">
                        <img src="${video.snippet.thumbnails.medium.url}" alt="${video.snippet.title}" class="w-full h-32 object-cover">
                    </div>
                    <div class="p-3">
                        <h4 class="font-semibold text-sm line-clamp-2 mb-2" title="${video.snippet.title}">
                            ${video.snippet.title}
                        </h4>
                        <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">
                            ${video.snippet.channelTitle}
                        </p>
                        <div class="flex gap-2">
                            <button 
                                onclick="handleVideoPlay('${video.id.videoId}', '${escapeHtml(video.snippet.title)}', '${escapeHtml(video.snippet.channelTitle)}', '${video.snippet.thumbnails.default.url}')" 
                                class="px-3 py-1 bg-primary text-white rounded hover:bg-opacity-90 transition-colors text-xs"
                            >
                                â–¶ï¸ æ’­æ”¾
                            </button>
                            <button 
                                onclick="showAddToPlaylistMenu('${video.id.videoId}', '${escapeHtml(video.snippet.title)}', '${escapeHtml(video.snippet.channelTitle)}', '${video.snippet.thumbnails.default.url}', this)" 
                                class="px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700 transition-colors text-xs"
                            >
                                â• æ·»åŠ 
                            </button>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function displayChannelResults(channels) {
            hideLoading();
            const resultsContainer = document.getElementById('searchResults');
            const noResultsDiv = document.getElementById('noResults');
            
            if (!channels || channels.length === 0) {
                resultsContainer.innerHTML = '';
                noResultsDiv.classList.remove('hidden');
                currentSearchData = null;
                return;
            }
            
            noResultsDiv.classList.add('hidden');
            
            // Store the current search data
            currentSearchData = {
                type: 'channels',
                data: channels,
                channelTitle: ''
            };
            
            resultsContainer.innerHTML = `
                <div class="col-span-full mb-4 text-center text-sm text-gray-600 dark:text-gray-400">
                    æ‰¾åˆ°äº† ${channels.length} å€‹é »é“
                </div>
            ` + channels.map(channel => `
                <div class="bg-white dark:bg-gray-700 rounded-lg shadow-md overflow-hidden">
                    <div class="relative">
                        <img src="${channel.snippet.thumbnails.medium?.url || channel.snippet.thumbnails.default?.url || ''}" alt="${channel.snippet.title}" class="w-full h-32 object-cover">
                    </div>
                    <div class="p-3">
                        <h4 class="font-semibold text-sm line-clamp-2 mb-2" title="${channel.snippet.title}">
                            ${channel.snippet.title}
                        </h4>
                        <p class="text-xs text-gray-600 dark:text-gray-400 mb-2 line-clamp-2">
                            ${channel.snippet.description || 'æ²’æœ‰æè¿°'}
                        </p>
                        <div class="flex gap-2">
                            <button 
                                onclick="viewChannelVideos('${channel.id.channelId}', '${escapeHtml(channel.snippet.title)}')" 
                                class="px-3 py-1 bg-primary text-white rounded hover:bg-opacity-90 transition-colors text-xs"
                            >
                                ğŸ“º å½±ç‰‡
                            </button>
                            <button 
                                onclick="viewChannelPlaylists('${channel.id.channelId}', '${escapeHtml(channel.snippet.title)}')" 
                                class="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors text-xs"
                            >
                                ğŸ“‹ æ’­æ”¾æ¸…å–®
                            </button>
                        </div>
                    </div>
                </div>
            `).join('');
        }



        function showNavigationBar(pathText) {
            document.getElementById('navigationBar').classList.remove('hidden');
            document.getElementById('navigationPath').textContent = pathText;
        }

        function hideNavigationBar() {
            document.getElementById('navigationBar').classList.add('hidden');
            navigationStack = [];
        }

        function navigateUp() {
            if (navigationStack.length > 0) {
                const previousState = navigationStack.pop();
                
                // Restore previous search state
                searchType = previousState.searchType;
                document.getElementById('searchInput').value = previousState.query;
                currentChannelId = previousState.channelId;
                
                // Update search type buttons
                setSearchTypeUI(searchType);
                
                // Show previous results using cached data (NO API calls)
                if (previousState.searchData) {
                    currentSearchData = previousState.searchData;
                    
                    if (previousState.searchData.type === 'channels') {
                        displayChannelResults(previousState.searchData.data);
                    } else if (previousState.searchData.type === 'playlists') {
                        displayYouTubePlaylists(previousState.searchData.data, previousState.searchData.channelTitle);
                    } else if (previousState.searchData.type === 'videos') {
                        displayVideoResults(previousState.searchData.data);
                    }
                } else {
                    clearSearchResults();
                }
                
                // Update navigation
                if (navigationStack.length === 0) {
                    hideNavigationBar();
                } else {
                    showNavigationBar(navigationStack[navigationStack.length - 1].pathText);
                }
            } else {
                hideNavigationBar();
                clearSearchResults();
            }
        }

        function setSearchTypeUI(type) {
            document.getElementById('videoSearchBtn').classList.toggle('bg-primary', type === 'video');
            document.getElementById('videoSearchBtn').classList.toggle('bg-gray-600', type !== 'video');
            document.getElementById('channelSearchBtn').classList.toggle('bg-primary', type === 'channel');
            document.getElementById('channelSearchBtn').classList.toggle('bg-gray-600', type !== 'channel');
            
            const placeholder = type === 'video' ? 'åœ¨YouTubeä¸­æœå°‹æˆ–è²¼ä¸Šé€£çµ' : 'æœå°‹é »é“Â·Â·Â·';
            document.getElementById('searchInput').placeholder = placeholder;
        }

        // URL Detection Functions
        function isYouTubeURL(input) {
            if (!input || typeof input !== 'string') return false;
            
            // Check if input contains YouTube domain patterns
            const youtubePatterns = [
                /^https?:\/\/(www\.|m\.)?youtube\.com/i,
                /^https?:\/\/youtu\.be/i,
                /^https?:\/\/gaming\.youtube\.com/i,
                /youtube\.com/i,
                /youtu\.be/i
            ];
            
            return youtubePatterns.some(pattern => pattern.test(input));
        }

        function handleURLFromSearch(url) {
            console.log('Handling URL from search:', url);
            
            // Show URL processing feedback
            const feedback = document.createElement('div');
            feedback.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 bg-primary text-white px-6 py-3 rounded-lg shadow-lg z-50 flex items-center gap-3';
            feedback.innerHTML = `
                <div class="animate-spin inline-block w-5 h-5 border-2 border-current border-t-transparent rounded-full"></div>
                <span>æ­£åœ¨è™•ç†YouTubeé€£çµÂ·Â·Â·</span>
            `;
            document.body.appendChild(feedback);
            
            // Use existing URL handling function
            setTimeout(() => {
                try {
                    handleAutoPlayURL(url);
                } catch (error) {
                    console.error('Error processing URL from search:', error);
                    showAutoPlayError('ç„¡æ³•è™•ç†å·²æä¾›é€£çµ');
                }
                
                // Remove processing feedback
                feedback.remove();
                
                // Clear the search input after processing
                document.getElementById('searchInput').value = '';
                
            }, 500); // Small delay to show processing feedback
        }

        function clearSearchResults() {
            document.getElementById('searchResults').innerHTML = '';
            document.getElementById('noResults').classList.add('hidden');
            document.getElementById('loadingState').classList.add('hidden');
            document.getElementById('searchInput').value = ''; // Clear search input text
            currentChannelId = null;
            currentSearchData = null;
            hideNavigationBar();
        }

        function escapeHtml(text) {
            return text.replace(/'/g, '&#39;').replace(/"/g, '&quot;');
        }

        function showLoading() {
            document.getElementById('loadingState').classList.remove('hidden');
            document.getElementById('searchResults').innerHTML = '';
            document.getElementById('noResults').classList.add('hidden');
        }

        function hideLoading() {
            document.getElementById('loadingState').classList.add('hidden');
        }

        // Playlist management
        function showCreatePlaylistForm() {
            document.getElementById('createPlaylistForm').classList.remove('hidden');
            document.getElementById('playlistNameInput').focus();
        }

        function hideCreatePlaylistForm() {
            document.getElementById('createPlaylistForm').classList.add('hidden');
            document.getElementById('playlistNameInput').value = '';
        }

        function createPlaylist() {
            const nameInput = document.getElementById('playlistNameInput');
            const name = nameInput.value.trim();
            
            if (!name) {
                alert('è«‹è¼¸å…¥æ’­æ”¾æ¸…å–®çš„åç¨±');
                return;
            }
            
            if (playlists[name]) {
                alert('æ’­æ”¾æ¸…å–®å·²ç¶“å­˜åœ¨');
                return;
            }
            
            playlists[name] = {
                name: name,
                videos: [],
                created: new Date().toISOString()
            };
            
            saveSettings();
            renderPlaylists();
            hideCreatePlaylistForm();
        }

        function deletePlaylist(name) {
            if (confirm(`åˆªé™¤æ’­æ”¾æ¸…å–®ã€Œ${name}ã€å—ï¼Ÿ`)) {
                delete playlists[name];
                if (currentPlaylist === name) {
                    clearCurrentPlaylist();
                }
                saveSettings();
                renderPlaylists();
            }
        }

        function renderPlaylists() {
            const container = document.getElementById('playlistsList');
            const playlistNames = Object.keys(playlists);
            
            if (playlistNames.length === 0) {
                container.innerHTML = '<p class="text-gray-600 dark:text-gray-400 text-sm">æš«ç„¡æ’­æ”¾æ¸…å–®ï¼Œç«‹å³å»ºç«‹æ’­æ”¾æ¸…å–®ï¼</p>';
                return;
            }
            
            container.innerHTML = playlistNames.map(name => `
                <div class="playlist-item p-3 bg-white dark:bg-gray-700 rounded-lg">
                    <div class="flex justify-between items-center mb-2">
                        <div class="flex-1 cursor-pointer" onclick="loadPlaylist('${name}')">
                            <div class="font-medium">${name}</div>
                            <div class="text-sm text-gray-600 dark:text-gray-400">${playlists[name].videos.length}éƒ¨å½±ç‰‡</div>
                        </div>
                        <button 
                            onclick="deletePlaylist('${name}')" 
                            class="text-red-500 hover:text-red-700 transition-colors ml-2"
                        >
                            ğŸ—‘ï¸
                        </button>
                    </div>
                    <div class="playlist-actions">
                        <button 
                            onclick="showRenameForm('${escapeHtml(name)}')" 
                            class="playlist-action-btn btn-rename"
                            title="é‡æ–°å‘½åæ’­æ”¾æ¸…å–®"
                        >
                            ğŸ“é‡æ–°å‘½å
                        </button>
                        <button 
                            onclick="duplicatePlaylist('${escapeHtml(name)}')" 
                            class="playlist-action-btn btn-duplicate"
                            title="è¤‡è£½æ’­æ”¾æ¸…å–®"
                        >
                            ğŸ“‹è¤‡è£½  
                        </button>
                        <button 
                            onclick="showMergeDialog('${escapeHtml(name)}')" 
                            class="playlist-action-btn btn-merge"
                            title="èˆ‡å…¶ä»–æ’­æ”¾æ¸…å–®åˆä½µ"
                        >
                            ğŸ”€åˆä½µ  
                        </button>
                        <button 
                            onclick="showOtherMenu('${escapeHtml(name)}', this)" 
                            class="playlist-action-btn bg-gray-600 hover:bg-gray-700"
                            title="æ›´å¤šé¸é …"
                        >
                            â‹¯ å…¶ä»–  
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function loadPlaylist(name) {
            currentPlaylist = name;
            currentVideoIndex = 0;
            renderCurrentPlaylist();
        }

        function clearCurrentPlaylist() {
            currentPlaylist = null;
            currentVideoIndex = 0;
            document.getElementById('currentPlaylistSection').classList.add('hidden');
            // Don't call clearVideo() - keep player running
        }

        function renderCurrentPlaylist() {
            if (!currentPlaylist) return;
            
            const section = document.getElementById('currentPlaylistSection');
            const title = document.getElementById('currentPlaylistTitle');
            const container = document.getElementById('currentPlaylistVideos');
            
            title.textContent = currentPlaylist;
            section.classList.remove('hidden');
            
            const videos = playlists[currentPlaylist].videos;
            
            if (videos.length === 0) {
                container.innerHTML = '<p class="text-gray-600 dark:text-gray-400 text-sm">é€™å€‹æ’­æ”¾æ¸…å–®é‚„æ²’æœ‰å½±ç‰‡ã€‚</p>';
                return;
            }
            
            const isSelectionMode = container.classList.contains('selection-mode');
            
            container.innerHTML = videos.map((video, index) => `
                <div class="playlist-video-item playlist-item flex items-center gap-3 p-2 rounded cursor-pointer ${index === currentVideoIndex ? 'active' : ''}" 
                     data-index="${index}"
                     draggable="${!isSelectionMode}"
                     onclick="${isSelectionMode ? `toggleVideoSelection(${index})` : `playVideoFromPlaylist(${index})`}"
                     ondragstart="handleDragStart(event, ${index})"
                     ondragover="handleDragOver(event)"
                     ondrop="handleDrop(event, ${index})"
                     ondragend="handleDragEnd(event)">
                    ${isSelectionMode ? `
                        <input type="checkbox" class="video-checkbox" data-index="${index}" onchange="updateSelectedCount()">
                    ` : ''}
                    <img src="${video.thumbnail}" alt="${video.title}" class="w-16 h-12 object-cover rounded ${!isSelectionMode ? 'cursor-grab' : ''}"
                         ${!isSelectionMode ? `
                         ontouchstart="handleVideoTouchStart(event, ${index})"
                         ontouchmove="handleVideoTouchMove(event, ${index})"
                         ontouchend="handleVideoTouchEnd(event, ${index})"
                         onclick="event.stopPropagation(); playVideoFromPlaylist(${index})"
                         ` : ''}>
                    <div class="flex-1 min-w-0">
                        <div class="font-medium text-sm line-clamp-2">${video.title}</div>
                        <div class="text-xs text-gray-600 dark:text-gray-400">${video.channel}</div>
                    </div>
                    ${!isSelectionMode ? `
                        <button 
                            onclick="removeFromPlaylist(${index}); event.stopPropagation();" 
                            class="text-red-500 hover:text-red-700 transition-colors"
                        >
                            âœ•
                        </button>
                    ` : ''}
                </div>
            `).join('');
        }

        function showAddToPlaylistMenu(videoId, title, channel, thumbnail, buttonElement) {
            const playlistNames = Object.keys(playlists);
            
            if (playlistNames.length === 0) {
                alert('Create a playlist first!');
                return;
            }
            
            // Remove any existing dropdown
            const existingDropdown = document.querySelector('.playlist-dropdown');
            if (existingDropdown) {
                existingDropdown.remove();
            }
            
            // Create dropdown menu
            const dropdown = document.createElement('div');
            dropdown.className = 'playlist-dropdown fixed bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg shadow-xl py-2 min-w-48 max-h-64 overflow-y-auto';
            dropdown.style.zIndex = '9999';
            
            // Add header
            const header = document.createElement('div');
            header.className = 'px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 border-b border-gray-200 dark:border-gray-600';
            header.textContent = 'æ·»åŠ è‡³æ’­æ”¾æ¸…å–®ï¼š';
            dropdown.appendChild(header);
            
            // Add playlist options
            playlistNames.forEach(playlistName => {
                const option = document.createElement('div');
                option.className = 'px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-600 cursor-pointer transition-colors';
                option.textContent = `${playlistName} (${playlists[playlistName].videos.length} videos)`;
                option.onclick = () => {
                    addToPlaylist(playlistName, { id: videoId, title, channel, thumbnail });
                    dropdown.remove();
                };
                dropdown.appendChild(option);
            });
            
            // Position dropdown using fixed positioning
            const buttonRect = buttonElement.getBoundingClientRect();
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;
            
            // Calculate position
            let top = buttonRect.bottom + 4;
            let left = buttonRect.left;
            
            // Adjust if dropdown would go off-screen
            const dropdownHeight = Math.min(playlistNames.length * 40 + 60, 256); // Estimate height
            const dropdownWidth = 192; // min-w-48 = 192px
            
            // Adjust vertical position if it goes below viewport
            if (top + dropdownHeight > viewportHeight) {
                top = buttonRect.top - dropdownHeight - 4;
            }
            
            // Adjust horizontal position if it goes off right edge
            if (left + dropdownWidth > viewportWidth) {
                left = viewportWidth - dropdownWidth - 10;
            }
            
            // Ensure it doesn't go off left edge
            if (left < 10) {
                left = 10;
            }
            
            dropdown.style.top = top + 'px';
            dropdown.style.left = left + 'px';
            
            // Append to body for better positioning
            document.body.appendChild(dropdown);
            
            // Close dropdown when clicking outside
            const closeDropdown = (e) => {
                if (!dropdown.contains(e.target) && e.target !== buttonElement) {
                    dropdown.remove();
                    document.removeEventListener('click', closeDropdown);
                }
            };
            
            // Add event listener after a small delay to prevent immediate closure
            setTimeout(() => {
                document.addEventListener('click', closeDropdown);
            }, 100);
        }

        function addToPlaylist(playlistName, video) {
            if (!playlists[playlistName]) return;
            
            // Check if video already exists in playlist
            const exists = playlists[playlistName].videos.some(v => v.id === video.id);
            if (exists) {
                alert('Video already in playlist!');
                return;
            }
            
            playlists[playlistName].videos.push(video);
            saveSettings();
            
            if (currentPlaylist === playlistName) {
                renderCurrentPlaylist();
            }
            
            renderPlaylists();
        }

        function removeFromPlaylist(index) {
            if (!currentPlaylist) return;
            
            playlists[currentPlaylist].videos.splice(index, 1);
            
            // Adjust current video index if needed
            if (currentVideoIndex >= index && currentVideoIndex > 0) {
                currentVideoIndex--;
            }
            
            saveSettings();
            renderCurrentPlaylist();
            renderPlaylists();
        }

        // Media Session API Integration
        function initializeMediaSession() {
            if ('mediaSession' in navigator) {
                console.log('Media Session API supported');
                
                // Set up action handlers
                navigator.mediaSession.setActionHandler('play', () => {
                    console.log('Media session: play requested');
                    userPausedManually = false; // Reset manual pause flag
                    if (player && player.playVideo) {
                        player.playVideo();
                    }
                });
                
                navigator.mediaSession.setActionHandler('pause', () => {
                    console.log('Media session: pause requested');
                    userPausedManually = true; // Mark as manual pause
                    if (player && player.pauseVideo) {
                        player.pauseVideo();
                    }
                });
                
                navigator.mediaSession.setActionHandler('previoustrack', () => {
                    console.log('Media session: previous track requested');
                    // Check if we have a current playlist with videos
                    if (currentPlaylist && playlists[currentPlaylist] && playlists[currentPlaylist].videos.length > 1) {
                        playPrevious();
                    } else {
                        console.log('No playlist or insufficient videos for previous track');
                    }
                });
                
                navigator.mediaSession.setActionHandler('nexttrack', () => {
                    console.log('Media session: next track requested');
                    // Check if we have a current playlist with videos
                    if (currentPlaylist && playlists[currentPlaylist] && playlists[currentPlaylist].videos.length > 1) {
                        playNext();
                    } else {
                        console.log('No playlist or insufficient videos for next track');
                    }
                });
                
                navigator.mediaSession.setActionHandler('stop', () => {
                    console.log('Media session: stop requested');
                    userPausedManually = true; // Mark as manual stop
                    clearVideo();
                });
                
                // Seek handlers for more granular control
                navigator.mediaSession.setActionHandler('seekbackward', (details) => {
                    if (player && player.getCurrentTime && player.seekTo) {
                        const currentTime = player.getCurrentTime();
                        const seekTime = Math.max(0, currentTime - (details.seekOffset || 10));
                        player.seekTo(seekTime);
                    }
                });
                
                navigator.mediaSession.setActionHandler('seekforward', (details) => {
                    if (player && player.getCurrentTime && player.seekTo && player.getDuration) {
                        const currentTime = player.getCurrentTime();
                        const duration = player.getDuration();
                        const seekTime = Math.min(duration, currentTime + (details.seekOffset || 10));
                        player.seekTo(seekTime);
                    }
                });
                
                navigator.mediaSession.setActionHandler('seekto', (details) => {
                    if (player && player.seekTo && details.seekTime) {
                        player.seekTo(details.seekTime);
                    }
                });
            } else {
                console.log('Media Session API not supported');
            }
        }
        
        function updateMediaSessionMetadata(title, artist, artwork) {
            if ('mediaSession' in navigator) {
                currentVideoInfo = { title, artist, artwork };
                
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: title,
                    artist: artist,
                    album: 'YouTube Player',
                    artwork: [
                        { src: artwork, sizes: '96x96', type: 'image/jpeg' },
                        { src: artwork, sizes: '128x128', type: 'image/jpeg' },
                        { src: artwork, sizes: '192x192', type: 'image/jpeg' },
                        { src: artwork, sizes: '256x256', type: 'image/jpeg' },
                        { src: artwork, sizes: '384x384', type: 'image/jpeg' },
                        { src: artwork, sizes: '512x512', type: 'image/jpeg' }
                    ]
                });
            }
        }
        
        function updateMediaSessionPlaybackState(playerState) {
            if ('mediaSession' in navigator) {
                // Update playback state based on YouTube player state
                switch (playerState) {
                    case YT.PlayerState.PLAYING:
                        navigator.mediaSession.playbackState = 'playing';
                        updateMediaSessionPosition();
                        break;
                    case YT.PlayerState.PAUSED:
                        navigator.mediaSession.playbackState = 'paused';
                        break;
                    case YT.PlayerState.ENDED:
                        navigator.mediaSession.playbackState = 'none';
                        break;
                    case YT.PlayerState.BUFFERING:
                        // Keep current state while buffering
                        break;
                    default:
                        navigator.mediaSession.playbackState = 'none';
                }
            }
        }
        
        function updateMediaSessionPosition() {
            if ('mediaSession' in navigator && player && player.getCurrentTime && player.getDuration) {
                try {
                    const currentTime = player.getCurrentTime();
                    const duration = player.getDuration();
                    const playbackRate = player.getPlaybackRate && player.getPlaybackRate() || 1;
                    
                    // Only update if we have valid data and aren't playing ads
                    if (currentTime >= 0 && currentTime <= duration && duration > 0 && duration < 86400 && !isAdPlaying) {
                        // Ensure position doesn't exceed duration
                        const safePosition = Math.min(currentTime, duration - 1);
                        
                        navigator.mediaSession.setPositionState({
                            duration: duration,
                            playbackRate: playbackRate,
                            position: safePosition
                        });
                    }
                } catch (error) {
                    console.log('Error updating media session position:', error);
                    // Clear position state on error to prevent stuck progress bars
                    try {
                        navigator.mediaSession.setPositionState({});
                    } catch (clearError) {
                        console.log('Error clearing position state:', clearError);
                    }
                }
            }
        }
        
        // Start periodic position updates when media session is active
        function startMediaSessionPositionUpdates() {
            // Update position every 5 seconds when playing
            setInterval(() => {
                if (player && navigator.mediaSession && navigator.mediaSession.playbackState === 'playing') {
                    updateMediaSessionPosition();
                }
            }, 5000);
        }

        // Video playback
        function playVideo(videoId, title, channel) {
            const videoContainer = document.getElementById('videoContainer');
            const videoTitle = document.getElementById('videoTitle');
            const videoChannel = document.getElementById('videoChannel');
            
            videoTitle.textContent = title;
            videoChannel.textContent = channel;
            videoContainer.classList.remove('hidden');
            
            // Initialize media session if not already done
            if (!navigator.mediaSession || !navigator.mediaSession.metadata) {
                initializeMediaSession();
                startMediaSessionPositionUpdates();
            }
            
            // Get video thumbnail URL for media session
            const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
            
            // Update media session metadata
            updateMediaSessionMetadata(title, channel, thumbnailUrl);
            
            // Initialize or update YouTube player
            if (!player) {
                // Wait for API to be ready
                if (!playerReady || !window.YT) {
                    setTimeout(() => playVideo(videoId, title, channel), 100);
                    return;
                }
                
                // Create new player
                player = new YT.Player('videoPlayer', {
                    height: '100%',
                    width: '100%',
                    videoId: videoId,
                    playerVars: {
                        autoplay: 1,
                        rel: 0,          // Reduce related videos
                        showinfo: 0,     // Hide video info
                        modestbranding: 1, // Reduce YouTube branding
                        iv_load_policy: 3, // Hide video annotations
                        cc_load_policy: 0, // Hide closed captions by default
                        fs: 1,           // Allow fullscreen
                        disablekb: 0,    // Enable keyboard controls
                        playsinline: 1,  // Enable inline playback on mobile
                        mediaPlaybackRequiresUserGesture: 0 // Allow background playback without user gesture
                    },
                    events: {
                        onStateChange: onPlayerStateChange,
                        onAdStateChange: onAdStateChange
                    }
                });
                
                // Start periodic ad checking
                setInterval(checkForAds, 1000); // Check every second
            } else {
                // Update existing player
                player.loadVideoById(videoId);
            }
            
            // Load video details for the drawer
            loadVideoDetails(videoId);
            
            videoContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // Video Details Drawer Functions
        let currentVideoDetails = null;

        function toggleVideoDetails() {
            const drawer = document.getElementById('videoDetailsDrawer');
            drawer.classList.toggle('open');
        }

        async function loadVideoDetails(videoId) {
            if (!apiKey) {
                showVideoDetailsError();
                return;
            }

            showVideoDetailsLoading();
            
            try {
                // Fetch video details including statistics
                const videoUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics,contentDetails&id=${videoId}&key=${apiKey}`;
                const videoResponse = await fetch(videoUrl);
                
                if (!videoResponse.ok) {
                    throw new Error(`Video API Error (${videoResponse.status})`);
                }
                
                const videoData = await videoResponse.json();
                
                if (!videoData.items || videoData.items.length === 0) {
                    throw new Error('Video not found');
                }
                
                const video = videoData.items[0];
                
                // Fetch channel details
                const channelUrl = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${video.snippet.channelId}&key=${apiKey}`;
                const channelResponse = await fetch(channelUrl);
                
                let channelData = null;
                if (channelResponse.ok) {
                    const channelJson = await channelResponse.json();
                    if (channelJson.items && channelJson.items.length > 0) {
                        channelData = channelJson.items[0];
                    }
                }
                
                // Store current video details
                currentVideoDetails = {
                    video: video,
                    channel: channelData
                };
                
                displayVideoDetails(video, channelData);
                
            } catch (error) {
                console.error('Video details error:', error);
                showVideoDetailsError();
            }
        }

        function displayVideoDetails(video, channel) {
            hideVideoDetailsLoading();
            
            // Show video statistics
            const stats = video.statistics;
            document.getElementById('viewCount').textContent = formatNumber(stats.viewCount || 0);
            document.getElementById('likeCount').textContent = formatNumber(stats.likeCount || 0);
            document.getElementById('commentCount').textContent = formatNumber(stats.commentCount || 0);
            document.getElementById('publishedDate').textContent = formatPublishDate(video.snippet.publishedAt);
            
            document.getElementById('videoStats').classList.remove('hidden');
            
            // Show video description with clickable @ mentions and # hashtags
            const description = video.snippet.description || 'æš«ç„¡æè¿°ã€‚';
            const processedDescription = processDescriptionLinks(description);
            document.getElementById('descriptionText').innerHTML = processedDescription;
            
            // Show expand button if description is long
            const expandBtn = document.getElementById('expandDescription');
            if (description.length > 300) {
                expandBtn.classList.remove('hidden');
                expandBtn.onclick = toggleDescription;
            } else {
                expandBtn.classList.add('hidden');
            }
            
            document.getElementById('videoDescription').classList.remove('hidden');
            
            // Show channel information
            if (channel) {
                document.getElementById('channelThumbnail').src = channel.snippet.thumbnails.default?.url || '';
                document.getElementById('channelTitle').textContent = channel.snippet.title;
                
                const subscriberCount = formatNumber(channel.statistics.subscriberCount || 0);
                document.getElementById('subscriberCount').textContent = `${subscriberCount} subscribers`;
                
                document.getElementById('channelInfo').classList.remove('hidden');
            }
        }

        function formatNumber(num) {
            const number = parseInt(num);
            if (number >= 1000000000) {
                return (number / 1000000000).toFixed(1) + 'B';
            } else if (number >= 1000000) {
                return (number / 1000000).toFixed(1) + 'M';
            } else if (number >= 1000) {
                return (number / 1000).toFixed(1) + 'K';
            }
            return number.toLocaleString();
        }

        function formatPublishDate(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffTime = Math.abs(now - date);
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            const diffMonths = Math.floor(diffDays / 30);
            const diffYears = Math.floor(diffDays / 365);
            
            if (diffDays === 0) return 'ä»Šå¤©';
            if (diffDays === 1) return 'æ˜¨å¤©';
            if (diffDays < 30) return `${diffDays} å¤©å‰`;
            if (diffMonths === 1) return '1 å€‹æœˆå‰';
            if (diffMonths < 12) return `${diffMonths} å€‹æœˆå‰`;
            if (diffYears === 1) return '1 å¹´å‰';
            return `${diffYears} å¹´å‰`;
        }

        function toggleDescription() {
            const content = document.querySelector('.description-content');
            const btn = document.getElementById('expandDescription');
            
            content.classList.toggle('expanded');
            btn.textContent = content.classList.contains('expanded') ? 'Show less' : 'Show more';
        }

        function showVideoDetailsLoading() {
            // Hide all sections
            document.getElementById('videoStats').classList.add('hidden');
            document.getElementById('videoDescription').classList.add('hidden');
            document.getElementById('channelInfo').classList.add('hidden');
            document.getElementById('videoDetailsError').classList.add('hidden');
            
            // Show loading
            document.getElementById('videoDetailsLoading').classList.remove('hidden');
        }

        function hideVideoDetailsLoading() {
            document.getElementById('videoDetailsLoading').classList.add('hidden');
        }

        function showVideoDetailsError() {
            // Hide all sections
            document.getElementById('videoStats').classList.add('hidden');
            document.getElementById('videoDescription').classList.add('hidden');
            document.getElementById('channelInfo').classList.add('hidden');
            document.getElementById('videoDetailsLoading').classList.add('hidden');
            
            // Show error
            document.getElementById('videoDetailsError').classList.remove('hidden');
        }

        function viewChannelFromDetails() {
            if (!currentVideoDetails || !currentVideoDetails.channel) return;
            
            const channel = currentVideoDetails.channel;
            viewChannelVideos(channel.id, channel.snippet.title);
        }

        // Main video handling function for the new queue system
        function handleVideoPlay(videoId, title, channel, thumbnail) {
            const video = { id: videoId, title, channel, thumbnail };
            
            // Show play options dialog if queue has videos
            if (playQueue.length > 0) {
                showPlayOptionsDialog(video, 'search');
            } else {
                // Queue is empty, add and play immediately
                addToQueue(video, 'current');
            }
        }

        // Modified playlist handling to integrate with queue system
        function handlePlaylistVideoClick(playlistName, index) {
            if (!playlists[playlistName]) return;
            
            const videos = playlists[playlistName].videos;
            if (index < 0 || index >= videos.length) return;
            
            // Show play options dialog if queue has videos
            if (playQueue.length > 0) {
                // Show dialog with playlist option
                showPlaylistPlayOptionsDialog(playlistName, index);
            } else {
                // Queue is empty, load playlist into queue and play
                addPlaylistToQueue(playlistName, index);
                playFromQueue(0);
            }
        }

        function showPlaylistPlayOptionsDialog(playlistName, videoIndex) {
            const video = playlists[playlistName].videos[videoIndex];
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'playlistOptionsOverlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'play-options-dialog';
            
            dialog.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">ğŸµæ·»åŠ è‡³æ’­æ”¾åˆ—è¡¨</h3>
                
                <div class="mb-4 p-3 bg-gray-50 dark:bg-gray-700 rounded-lg">
                    <div class="font-medium text-sm line-clamp-2 mb-1">${video.title}</div>
                    <div class="text-xs text-gray-600 dark:text-gray-400">${video.channel}</div>
                    <div class="text-xs text-blue-600 dark:text-blue-400 mt-1">ä¾†è‡ªæ’­æ”¾æ¸…å–®ï¼š${playlistName}</div>
                </div>
                
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                    æ’­æ”¾åˆ—è¡¨å·²ç¶“æœ‰${playQueue.length}éƒ¨å½±ç‰‡ï¼Œæ‚¨æƒ³è¦å¦‚ä½•æ·»åŠ ï¼Ÿ
                </p>
                
                <div class="space-y-2 mb-6">
                    <button onclick="addToQueue(${JSON.stringify(video).replace(/"/g, '&quot;')}, 'current'); hidePlaylistOptionsDialog()" class="play-option-btn">
                        <div class="play-option-icon">â–¶ï¸</div>
                        <div class="play-option-content">
                            <div class="play-option-title">ç¾åœ¨æ’­æ”¾é€™å€‹å½±ç‰‡</div>
                            <div class="play-option-desc">åœæ­¢ç•¶å‰å½±ç‰‡ä¸¦ç«‹å³æ’­æ”¾æ­¤å½±ç‰‡</div>
                        </div>
                    </button>
                    
                    <button onclick="clearQueueAndLoadPlaylist('${escapeHtml(playlistName)}', ${videoIndex}); hidePlaylistOptionsDialog()" class="play-option-btn">
                        <div class="play-option-icon">ğŸ“‹</div>
                        <div class="play-option-content">
                            <div class="play-option-title">æ’­æ”¾æ•´å€‹æ’­æ”¾æ¸…å–®</div>
                            <div class="play-option-desc">å¾é€™å€‹å½±ç‰‡é–‹å§‹ï¼Œç”¨é€™å€‹æ’­æ”¾æ¸…å–®æ›¿æ›åˆ—è¡¨</div>
                        </div>
                    </button>
                    
                    <button onclick="addToQueue(${JSON.stringify(video).replace(/"/g, '&quot;')}, 'next'); hidePlaylistOptionsDialog()" class="play-option-btn">
                        <div class="play-option-icon">â­ï¸</div>
                        <div class="play-option-content">
                            <div class="play-option-title">æ¥ä¸‹ä¾†æ’­æ”¾</div>
                            <div class="play-option-desc">åœ¨ç•¶å‰å½±ç‰‡ä¹‹å¾Œæ–°å¢æ­¤å½±ç‰‡</div>
                        </div>
                    </button>
                    
                    <button onclick="addToQueue(${JSON.stringify(video).replace(/"/g, '&quot;')}, 'end'); hidePlaylistOptionsDialog()" class="play-option-btn">
                        <div class="play-option-icon">ğŸ“</div>
                        <div class="play-option-content">
                            <div class="play-option-title">æ–°å¢åˆ°çµå°¾</div>
                            <div class="play-option-desc">å°‡æ­¤å½±ç‰‡æ–°å¢åˆ°æ’­æ”¾åˆ—è¡¨æœ«å°¾</div>
                        </div>
                    </button>
                </div>
                
                <div class="flex gap-3 justify-end">
                    <button onclick="hidePlaylistOptionsDialog()" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors">
                        å–æ¶ˆ
                    </button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hidePlaylistOptionsDialog();
                }
            });
        }

        function hidePlaylistOptionsDialog() {
            const overlay = document.getElementById('playlistOptionsOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        function clearQueueAndLoadPlaylist(playlistName, startIndex = 0) {
            // Clear current queue
            playQueue = [];
            currentQueueIndex = 0;
            
            // Load playlist into queue
            addPlaylistToQueue(playlistName, startIndex);
            
            // Start playing
            if (playQueue.length > 0) {
                playFromQueue(0);
            }
        }

        function playVideoFromPlaylist(index) {
            if (!currentPlaylist) return;
            
            const videos = playlists[currentPlaylist].videos;
            if (index < 0 || index >= videos.length) return;
            
            // Use new queue-based system
            handlePlaylistVideoClick(currentPlaylist, index);
            
            // Update UI to show current selection
            currentVideoIndex = index;
            renderCurrentPlaylist(); // Update active indicator
        }

        function clearVideo() {
            const videoContainer = document.getElementById('videoContainer');
            
            // Clear media session
            if ('mediaSession' in navigator) {
                navigator.mediaSession.playbackState = 'none';
                navigator.mediaSession.metadata = null;
            }
            
            // Destroy YouTube player if it exists
            if (player && player.destroy) {
                player.destroy();
                player = null;
            }
            
            videoContainer.classList.add('hidden');
        }

        // Playback controls
        function toggleShuffle() {
            playbackSettings.shuffle = !playbackSettings.shuffle;
            saveSettings();
            updatePlaybackUI();
        }

        function toggleRepeat() {
            const modes = ['é—œé–‰', 'æ‰€æœ‰', 'å–®æ›²'];
            const currentIndex = modes.indexOf(playbackSettings.repeat);
            playbackSettings.repeat = modes[(currentIndex + 1) % modes.length];
            saveSettings();
            updatePlaybackUI();
        }

        function updatePlaybackUI() {
            document.getElementById('shuffleStatus').textContent = playbackSettings.shuffle ? 'é–‹å•Ÿ' : 'é—œé–‰';
            document.getElementById('shuffleBtn').classList.toggle('bg-primary', playbackSettings.shuffle);
            document.getElementById('shuffleBtn').classList.toggle('bg-gray-600', !playbackSettings.shuffle);
            
            const repeatText = playbackSettings.repeat === 'é—œé–‰' ? 'é—œé–‰' : 
                              playbackSettings.repeat === 'æ‰€æœ‰' ? 'æ‰€æœ‰' : 'å–®æ›²';
            document.getElementById('repeatStatus').textContent = repeatText;
            document.getElementById('repeatBtn').classList.toggle('bg-primary', playbackSettings.repeat !== 'é—œé–‰');
            document.getElementById('repeatBtn').classList.toggle('bg-gray-600', playbackSettings.repeat === 'é—œé–‰');
        }

        function playNext() {
            // Use queue system if queue has videos
            if (playQueue.length > 0) {
                let nextIndex;
                
                if (playbackSettings.shuffle) {
                    // Shuffle mode: pick random video from queue
                    nextIndex = Math.floor(Math.random() * playQueue.length);
                } else {
                    // Normal mode: next video in queue
                    nextIndex = currentQueueIndex + 1;
                    
                    // If at end of queue
                    if (nextIndex >= playQueue.length) {
                        if (playbackSettings.repeat === 'all') {
                            nextIndex = 0; // Loop back to start
                        } else {
                            return; // Stop playing
                        }
                    }
                }
                
                playFromQueue(nextIndex);
                return;
            }
            
            playVideoFromPlaylist(nextIndex);
        }

        function playPrevious() {
            // Use queue system if queue has videos
            if (playQueue.length > 0) {
                let prevIndex;
                
                if (playbackSettings.shuffle) {
                    // Shuffle mode: pick random video from queue
                    prevIndex = Math.floor(Math.random() * playQueue.length);
                } else {
                    // Normal mode: previous video in queue
                    prevIndex = currentQueueIndex - 1;
                    
                    // If at beginning of queue
                    if (prevIndex < 0) {
                        if (playbackSettings.repeat === 'all') {
                            prevIndex = playQueue.length - 1; // Loop to end
                        } else {
                            return; // Stop playing
                        }
                    }
                }
                
                playFromQueue(prevIndex);
                return;
            }
            
            playVideoFromPlaylist(prevIndex);
        }

        // Channel content functions
        async function viewChannelVideos(channelId, channelTitle) {
            // Save current state to navigation stack
            if (currentSearchData) {
                navigationStack.push({
                    searchType: searchType,
                    query: document.getElementById('searchInput').value,
                    channelId: currentChannelId,
                    searchData: currentSearchData,
                    pathText: `${channelTitle} - Channels`
                });
            }
            
            currentChannelId = channelId;
            document.getElementById('searchInput').value = `${channelTitle} - Videos`;
            showNavigationBar(`${channelTitle} - Videos`);
            await searchVideos(channelId);
        }

        async function viewChannelPlaylists(channelId, channelTitle) {
            if (!apiKey) {
                alert('Please set up your API key first');
                return;
            }
            
            // Save current state to navigation stack
            if (currentSearchData) {
                navigationStack.push({
                    searchType: searchType,
                    query: document.getElementById('searchInput').value,
                    channelId: currentChannelId,
                    searchData: currentSearchData,
                    pathText: `${channelTitle} - Channels`
                });
            }
            
            showLoading();
            
            try {
                const url = `https://www.googleapis.com/youtube/v3/playlists?part=snippet&channelId=${channelId}&maxResults=50&key=${apiKey}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`API Error (${response.status})`);
                }
                
                const data = await response.json();
                showNavigationBar(`${channelTitle} - Playlists`);
                displayYouTubePlaylists(data.items, channelTitle);
                
            } catch (error) {
                console.error('Playlist search error:', error);
                hideLoading();
                alert(`Failed to load playlists: ${error.message}`);
            }
        }

        function displayYouTubePlaylists(playlists, channelTitle) {
            hideLoading();
            const resultsContainer = document.getElementById('searchResults');
            const noResultsDiv = document.getElementById('noResults');
            
            if (!playlists || playlists.length === 0) {
                resultsContainer.innerHTML = '';
                noResultsDiv.classList.remove('hidden');
                currentSearchData = null;
                return;
            }
            
            noResultsDiv.classList.add('hidden');
            document.getElementById('searchInput').value = `${channelTitle} - Playlists`;
            
            // Store the current search data
            currentSearchData = {
                type: 'playlists',
                data: playlists,
                channelTitle: channelTitle
            };
            
            resultsContainer.innerHTML = `
                <div class="col-span-full mb-4 text-center text-sm text-gray-600 dark:text-gray-400">
                    æ‰¾åˆ°äº†${playlists.length}å€‹æ’­æ”¾æ¸…å–®
                </div>
            ` + playlists.map(playlist => `
                <div class="bg-white dark:bg-gray-700 rounded-lg shadow-md overflow-hidden">
                    <div class="relative">
                        <img src="${playlist.snippet.thumbnails.medium?.url || playlist.snippet.thumbnails.default?.url || ''}" alt="${playlist.snippet.title}" class="w-full h-32 object-cover">
                        <div class="absolute bottom-2 right-2 bg-black bg-opacity-75 text-white text-xs px-2 py-1 rounded">
                            ğŸ“‹æ’­æ”¾æ¸…å–®
                        </div>
                    </div>
                    <div class="p-3">
                        <h4 class="font-semibold text-sm line-clamp-2 mb-2" title="${playlist.snippet.title}">
                            ${playlist.snippet.title}
                        </h4>
                        <p class="text-xs text-gray-600 dark:text-gray-400 mb-2">
                            ${playlist.snippet.channelTitle}
                        </p>
                        <div class="flex gap-2">
                            <button 
                                onclick="viewPlaylistVideos('${playlist.id}', '${escapeHtml(playlist.snippet.title)}')" 
                                class="px-3 py-1 bg-primary text-white rounded hover:bg-opacity-90 transition-colors text-xs"
                            >
                                ğŸ“ºæŸ¥çœ‹å½±ç‰‡
                            </button>
                            <button 
                                onclick="importYouTubePlaylist('${playlist.id}', '${escapeHtml(playlist.snippet.title)}')" 
                                class="px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700 transition-colors text-xs"
                            >
                                ğŸ“¥åŒ¯å…¥
                            </button>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        async function viewPlaylistVideos(playlistId, playlistTitle) {
            if (!apiKey) {
                alert('Please set up your API key first');
                return;
            }
            
            // Save current state to navigation stack (the playlists view)
            if (currentSearchData) {
                // Get the current navigation path to save it properly
                const currentPath = document.getElementById('navigationPath').textContent;
                
                navigationStack.push({
                    searchType: searchType,
                    query: document.getElementById('searchInput').value,
                    channelId: currentChannelId,
                    searchData: currentSearchData,
                    pathText: currentPath
                });
            }
            
            showLoading();
            
            try {
                const url = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&playlistId=${playlistId}&maxResults=50&key=${apiKey}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`API Error (${response.status})`);
                }
                
                const data = await response.json();
                const videos = data.items.map(item => ({
                    id: { videoId: item.snippet.resourceId.videoId },
                    snippet: item.snippet
                }));
                displayVideoResults(videos);
                document.getElementById('searchInput').value = `${playlistTitle} - Videos`;
                showNavigationBar(`${playlistTitle} - Videos`);
                
            } catch (error) {
                console.error('Playlist videos error:', error);
                hideLoading();
                alert(`Failed to load playlist videos: ${error.message}`);
            }
        }

        // Global variable to store current search results data
        let currentSearchData = null;

        async function importYouTubePlaylist(playlistId, playlistTitle) {
            if (!apiKey) {
                alert('Please set up your API key first');
                return;
            }
            
            if (playlists[playlistTitle]) {
                if (!confirm(`Playlist "${playlistTitle}" already exists. Overwrite it?`)) {
                    return;
                }
            }
            
            // Show import progress without clearing search results
            showImportProgress(playlistTitle);
            
            try {
                // Import ALL videos from playlist (no limits)
                let allVideos = [];
                let nextPageToken = '';
                let totalFetched = 0;
                
                do {
                    const url = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&playlistId=${playlistId}&maxResults=50${nextPageToken ? '&pageToken=' + nextPageToken : ''}&key=${apiKey}`;
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        throw new Error(`API Error (${response.status})`);
                    }
                    
                    const data = await response.json();
                    const videos = data.items.map(item => ({
                        id: item.snippet.resourceId.videoId,
                        title: item.snippet.title,
                        channel: item.snippet.videoOwnerChannelTitle || item.snippet.channelTitle,
                        thumbnail: item.snippet.thumbnails.default?.url || ''
                    }));
                    
                    allVideos = allVideos.concat(videos);
                    totalFetched += videos.length;
                    nextPageToken = data.nextPageToken || '';
                    
                    // Update progress
                    updateImportProgress(`Importing... ${totalFetched} videos fetched`);
                    
                } while (nextPageToken);
                
                playlists[playlistTitle] = {
                    name: playlistTitle,
                    videos: allVideos,
                    created: new Date().toISOString(),
                    imported: true
                };
                
                saveSettings();
                renderPlaylists();
                hideImportProgress();
                
                // Show success message without affecting search results
                showImportSuccessMessage(`âœ… Successfully imported "${playlistTitle}" with ${allVideos.length} videos!`);
                
            } catch (error) {
                console.error('Import playlist error:', error);
                hideImportProgress();
                showImportErrorMessage(`âŒ Failed to import playlist: ${error.message}`);
            }
        }

        // Event listeners
        document.getElementById('searchInput').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                performSearch();
            }
        });

        document.getElementById('playlistNameInput').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                createPlaylist();
            }
        });

        // Background Playback System
        function initializeBackgroundPlayback() {
            console.log('Initializing background playback system...');
            
            // Initialize Audio Context for background playback
            initializeAudioContext();
            
            // Set up Page Visibility API
            setupPageVisibilityHandling();
            
            // Set up Wake Lock (if supported)
            setupWakeLock();
            
            // Set up beforeunload handling
            setupUnloadHandling();
            
            // Ensure media session is active
            if ('mediaSession' in navigator) {
                // Set initial playback state
                navigator.mediaSession.playbackState = 'none';
            }
            
            console.log('Background playback system initialized');
        }
        
        function initializeAudioContext() {
            try {
                // Create AudioContext to maintain audio processing in background
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                if (window.AudioContext) {
                    audioContext = new AudioContext();
                    
                    // Create a silent audio buffer to keep context active
                    const buffer = audioContext.createBuffer(1, 1, 22050);
                    const source = audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.connect(audioContext.destination);
                    source.start();
                    
                    console.log('Audio context initialized for background playback');
                }
            } catch (error) {
                console.log('Audio context initialization failed:', error);
            }
        }
        
        function setupPageVisibilityHandling() {
            // Page Visibility API to handle tab switching
            let visibilityChange;
            let hidden;
            
            if (typeof document.hidden !== "undefined") {
                hidden = "hidden";
                visibilityChange = "visibilitychange";
            } else if (typeof document.msHidden !== "undefined") {
                hidden = "msHidden";
                visibilityChange = "msvisibilitychange";
            } else if (typeof document.webkitHidden !== "undefined") {
                hidden = "webkitHidden";
                visibilityChange = "webkitvisibilitychange";
            }
            
            if (typeof document[hidden] !== "undefined") {
                document.addEventListener(visibilityChange, handleVisibilityChange, false);
                console.log('Page visibility handling enabled');
            }
            
            // Handle page focus/blur events as backup
            window.addEventListener('focus', handlePageFocus);
            window.addEventListener('blur', handlePageBlur);
        }
        
        function handleVisibilityChange() {
            isPageVisible = !document.hidden;
            
            if (!backgroundPlaybackEnabled || !player) return;
            
            if (isPageVisible) {
                console.log('Page became visible - resuming normal playback');
                handlePageFocus();
            } else {
                console.log('Page became hidden - maintaining background playback');
                handlePageBlur();
            }
        }
        
        function handlePageFocus() {
            // Page became visible/focused
            if (player && backgroundPlaybackEnabled) {
                // Resume audio context if suspended
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().catch(console.error);
                }
                
                // Ensure video continues playing if it was playing
                try {
                    const state = player.getPlayerState();
                    if (state === YT.PlayerState.PAUSED && navigator.mediaSession?.playbackState === 'playing') {
                        // Resume if media session indicates it should be playing
                        player.playVideo();
                    }
                } catch (error) {
                    console.log('Error resuming playback on focus:', error);
                }
            }
        }
        
        function handlePageBlur() {
            // Page became hidden/lost focus
            if (player && backgroundPlaybackEnabled && !userPausedManually) {
                try {
                    const state = player.getPlayerState();
                    
                    // Only try to maintain playback if user didn't manually pause
                    if (state === YT.PlayerState.PLAYING || lastKnownPlaybackState === YT.PlayerState.PLAYING) {
                        console.log('Maintaining background playback...');
                        
                        // Maintain audio context
                        if (audioContext && audioContext.state !== 'running') {
                            audioContext.resume().catch(console.error);
                        }
                        
                        // Apply background playback strategies
                        maintainBackgroundPlayback();
                    }
                    
                } catch (error) {
                    console.log('Error in background playback handling:', error);
                }
            } else if (userPausedManually) {
                console.log('User manually paused - not attempting background playback');
            }
        }
        
        function maintainBackgroundPlayback() {
            if (!player || !backgroundPlaybackEnabled) return;
            
            try {
                // Strategy 1: Ensure media session is properly set
                if ('mediaSession' in navigator && currentVideoInfo.title) {
                    updateMediaSessionMetadata(currentVideoInfo.title, currentVideoInfo.artist, currentVideoInfo.artwork);
                    navigator.mediaSession.playbackState = 'playing';
                }
                
                // Strategy 2: Keep audio context active
                if (audioContext) {
                    // Create periodic silent audio to maintain context
                    setInterval(() => {
                        if (!isPageVisible && audioContext.state === 'running') {
                            const buffer = audioContext.createBuffer(1, 1, 22050);
                            const source = audioContext.createBufferSource();
                            source.buffer = buffer;
                            source.connect(audioContext.destination);
                            source.start();
                        }
                    }, 10000); // Every 10 seconds
                }
                
                // Strategy 3: Prevent player from being paused by mobile browser
                const checkPlaybackState = () => {
                    if (!isPageVisible && player && !userPausedManually && backgroundPlaybackEnabled) {
                        try {
                            const state = player.getPlayerState();
                            const mediaSessionState = navigator.mediaSession?.playbackState;
                            
                            // Only resume if:
                            // 1. Player is paused
                            // 2. User didn't manually pause 
                            // 3. Media session shows we should be playing
                            // 4. Background playback is enabled
                            if (state === YT.PlayerState.PAUSED && 
                                mediaSessionState === 'playing' && 
                                !userPausedManually) {
                                
                                console.log('Attempting to resume background playback...');
                                
                                // Try to resume playback (with limited attempts)
                                let attemptCount = 0;
                                const resumeAttempt = () => {
                                    if (player && player.playVideo && attemptCount < 2 && !userPausedManually) {
                                        player.playVideo();
                                        attemptCount++;
                                        
                                        setTimeout(() => {
                                            // Check again after a short delay
                                            if (player.getPlayerState() === YT.PlayerState.PAUSED && 
                                                !userPausedManually && 
                                                navigator.mediaSession?.playbackState === 'playing') {
                                                resumeAttempt();
                                            }
                                        }, 500);
                                    }
                                };
                                resumeAttempt();
                            }
                        } catch (error) {
                            console.log('Error checking playback state:', error);
                        }
                    }
                };
                
                // Check every 1 second when page is hidden for faster response
                const backgroundCheck = setInterval(() => {
                    if (isPageVisible) {
                        clearInterval(backgroundCheck);
                        return;
                    }
                    checkPlaybackState();
                }, 1000);
                
                // Strategy 4: Use Web Locks API to maintain active state
                if ('locks' in navigator) {
                    navigator.locks.request('background-playback', { mode: 'shared' }, () => {
                        return new Promise((resolve) => {
                            // Keep lock active while playing in background
                            const checkLock = () => {
                                if (isPageVisible || !backgroundPlaybackEnabled || !player) {
                                    resolve();
                                    return;
                                }
                                setTimeout(checkLock, 5000);
                            };
                            checkLock();
                        });
                    }).catch(console.error);
                }
                
            } catch (error) {
                console.log('Error in maintainBackgroundPlayback:', error);
            }
        }
        
        function setupWakeLock() {
            // Screen Wake Lock API to prevent device sleep during playback
            if ('wakeLock' in navigator) {
                const requestWakeLock = async () => {
                    try {
                        wakeLock = await navigator.wakeLock.request('screen');
                        console.log('Screen wake lock activated');
                        
                        wakeLock.addEventListener('release', () => {
                            console.log('Screen wake lock released');
                            wakeLock = null;
                        });
                    } catch (error) {
                        console.log('Wake lock request failed:', error);
                    }
                };
                
                // Request wake lock when video starts playing
                const originalPlayVideo = window.playVideo;
                if (originalPlayVideo) {
                    window.playVideo = function(...args) {
                        requestWakeLock();
                        return originalPlayVideo.apply(this, args);
                    };
                }
            }
        }
        
        function setupUnloadHandling() {
            // Handle page unload to maintain playback state
            window.addEventListener('beforeunload', (event) => {
                if (player && backgroundPlaybackEnabled) {
                    try {
                        const state = player.getPlayerState();
                        if (state === YT.PlayerState.PLAYING) {
                            // Save current playback state
                            const currentTime = player.getCurrentTime();
                            const videoId = player.getVideoData && player.getVideoData().video_id;
                            
                            if (videoId && currentTime) {
                                setLocalStorage('ytplayer_last_position', {
                                    videoId: videoId,
                                    currentTime: currentTime,
                                    timestamp: Date.now()
                                });
                            }
                        }
                    } catch (error) {
                        console.log('Error saving playback state:', error);
                    }
                }
            });
            
            // Handle page show (when returning from background)
            window.addEventListener('pageshow', (event) => {
                if (event.persisted) {
                    // Page was restored from cache
                    handlePageFocus();
                }
            });
        }
        
        function enableBackgroundPlayback() {
            backgroundPlaybackEnabled = true;
            console.log('Background playback enabled');
            
            // Initialize audio context if not already done
            if (!audioContext) {
                initializeAudioContext();
            }
        }
        
        function disableBackgroundPlayback() {
            backgroundPlaybackEnabled = false;
            console.log('Background playback disabled');
            
            // Release wake lock if active
            if (wakeLock) {
                wakeLock.release();
                wakeLock = null;
            }
        }

        // Enhanced Playlist Management Features

        // Drag and Drop Variables
        let draggedIndex = null;
        let draggedElement = null;

        // Selection Mode Variables
        let isSelectionMode = false;
        let selectedVideos = new Set();

        // Rename Playlist Functions
        function showRenameForm(oldName) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'renameOverlay';
            
            const form = document.createElement('div');
            form.className = 'rename-form';
            
            form.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">é‡æ–°å‘½åæ’­æ”¾æ¸…å–®</h3>
                <input 
                    type="text" 
                    id="renameInput" 
                    value="${oldName}"
                    class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded mb-4 bg-white dark:bg-gray-800 text-gray-900 dark:text-white"
                    placeholder="è¼¸å…¥æ–°çš„åç¨±Â·Â·Â·"
                >
                <div class="flex gap-3 justify-end">
                    <button 
                        onclick="hideRenameForm()" 
                        class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
                    >
                        å–æ¶ˆ
                    </button>
                    <button 
                        onclick="confirmRename('${escapeHtml(oldName)}')" 
                        class="px-4 py-2 bg-primary text-white rounded hover:bg-opacity-90 transition-colors"
                    >
                        é‡æ–°å‘½å
                    </button>
                </div>
            `;
            
            overlay.appendChild(form);
            document.body.appendChild(overlay);
            
            // Focus input and select text
            const input = document.getElementById('renameInput');
            input.focus();
            input.select();
            
            // Handle Enter key
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    confirmRename(oldName);
                }
            });
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hideRenameForm();
                }
            });
        }

        function hideRenameForm() {
            const overlay = document.getElementById('renameOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        function confirmRename(oldName) {
            const input = document.getElementById('renameInput');
            const newName = input.value.trim();
            
            if (!newName) {
                alert('è«‹è¼¸å…¥ä¸€å€‹æœ‰æ•ˆçš„åå­—');
                return;
            }
            
            if (newName === oldName) {
                hideRenameForm();
                return;
            }
            
            if (playlists[newName]) {
                alert('æ­¤åç¨±çš„æ’­æ”¾æ¸…å–®å·²ç¶“å­˜åœ¨');
                return;
            }
            
            // Rename the playlist
            playlists[newName] = { ...playlists[oldName] };
            playlists[newName].name = newName;
            delete playlists[oldName];
            
            // Update current playlist if it was renamed
            if (currentPlaylist === oldName) {
                currentPlaylist = newName;
            }
            
            saveSettings();
            renderPlaylists();
            renderCurrentPlaylist();
            hideRenameForm();
        }

        // Merge Playlists Functions
        function showMergeDialog(targetPlaylist) {
            const playlistNames = Object.keys(playlists).filter(name => name !== targetPlaylist);
            
            if (playlistNames.length === 0) {
                alert('æ²’æœ‰å¯åˆä½µçš„æ’­æ”¾æ¸…å–®');
                return;
            }
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'mergeOverlay';
            
            const form = document.createElement('div');
            form.className = 'rename-form';
            
            // Responsive width handling
            if (window.innerWidth <= 640) {
                form.style.minWidth = 'calc(100vw - 32px)';
                form.style.maxWidth = 'calc(100vw - 32px)';
                form.style.width = 'calc(100vw - 32px)';
            } else {
                form.style.minWidth = '400px';
            }
            
            form.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">Merge Playlists</h3>
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                    é¸æ“‡è¦åˆä½µå…¥ã€Œ${targetPlaylist}ã€çš„æ’­æ”¾æ¸…å–®ï¼š
                </p>
                <div class="max-h-64 overflow-y-auto mb-4 space-y-2">
                    ${playlistNames.map(name => `
                        <label class="flex items-center gap-2 p-2 hover:bg-gray-100 dark:hover:bg-gray-600 rounded cursor-pointer">
                            <input type="checkbox" value="${name}" class="merge-checkbox">
                            <span class="flex-1">${name} (${playlists[name].videos.length}æ¢å½±ç‰‡)</span>
                        </label>
                    `).join('')}
                </div>
                <div class="flex gap-3 justify-end">
                    <button 
                        onclick="hideMergeDialog()" 
                        class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
                    >
                        å–æ¶ˆ
                    </button>
                    <button 
                        onclick="confirmMerge('${escapeHtml(targetPlaylist)}')" 
                        class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition-colors"
                    >
                        åˆä½µ
                    </button>
                </div>
            `;
            
            overlay.appendChild(form);
            document.body.appendChild(overlay);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hideMergeDialog();
                }
            });
        }

        function hideMergeDialog() {
            const overlay = document.getElementById('mergeOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        function confirmMerge(targetPlaylist) {
            const checkboxes = document.querySelectorAll('.merge-checkbox:checked');
            const selectedPlaylists = Array.from(checkboxes).map(cb => cb.value);
            
            if (selectedPlaylists.length === 0) {
                alert('è«‹è‡³å°‘é¸æ“‡ä¸€å€‹è¦åˆä½µçš„æ’­æ”¾æ¸…å–®');
                return;
            }
            
            let totalVideos = 0;
            const allVideos = [...playlists[targetPlaylist].videos];
            const existingVideoIds = new Set(allVideos.map(v => v.id));
            
            // Merge videos from selected playlists
            selectedPlaylists.forEach(playlistName => {
                const videos = playlists[playlistName].videos;
                videos.forEach(video => {
                    if (!existingVideoIds.has(video.id)) {
                        allVideos.push(video);
                        existingVideoIds.add(video.id);
                        totalVideos++;
                    }
                });
                
                // Delete the merged playlist
                delete playlists[playlistName];
                
                // Clear current playlist if it was one of the merged ones
                if (currentPlaylist === playlistName) {
                    clearCurrentPlaylist();
                }
            });
            
            playlists[targetPlaylist].videos = allVideos;
            
            saveSettings();
            renderPlaylists();
            renderCurrentPlaylist();
            hideMergeDialog();
            
            alert(`${selectedPlaylists.length}å€‹æ’­æ”¾æ¸…å–®åˆä½µæˆåŠŸã€‚å·²åŠ å…¥${totalVideos}æ¢æ–°å½±ç‰‡å…¥ã€Œ${targetPlaylist}ã€ã€‚`);
        }

        // Duplicate Playlist
        function duplicatePlaylist(playlistName) {
            let newName = `${playlistName}ï¼ˆå‰¯æœ¬ï¼‰`;
            let counter = 2;
            
            while (playlists[newName]) {
                newName = `${playlistName}ï¼ˆå‰¯æœ¬${counter}ï¼‰`;
                counter++;
            }
            
            playlists[newName] = {
                name: newName,
                videos: [...playlists[playlistName].videos],
                created: new Date().toISOString(),
                duplicatedFrom: playlistName
            };
            
            saveSettings();
            renderPlaylists();
        }

        // Show Playlist Info
        function showPlaylistInfo(playlistName) {
            const playlist = playlists[playlistName];
            const createdDate = new Date(playlist.created).toLocaleDateString();
            const remarks = playlist.remarks || '';
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'playlistInfoOverlay';
            
            const form = document.createElement('div');
            form.className = 'rename-form';
            
            // Responsive width handling
            if (window.innerWidth <= 640) {
                form.style.minWidth = 'calc(100vw - 32px)';
                form.style.maxWidth = 'calc(100vw - 32px)';
                form.style.width = 'calc(100vw - 32px)';
            } else {
                form.style.minWidth = '400px';
                form.style.maxWidth = '500px';
            }
            
            form.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">ğŸ“Š æ’­æ”¾æ¸…å–®è³‡è¨Š</h3>
                
                <div class="space-y-3 mb-4">
                    <div class="flex justify-between">
                        <span class="font-medium text-gray-700 dark:text-gray-300">åç¨±ï¼š</span>
                        <span class="text-gray-900 dark:text-white">${playlistName}</span>
                    </div>
                    
                    <div class="flex justify-between">
                        <span class="font-medium text-gray-700 dark:text-gray-300">å½±ç‰‡ï¼š</span>
                        <span class="text-gray-900 dark:text-white">${playlist.videos.length}</span>
                    </div>
                    
                    <div class="flex justify-between">
                        <span class="font-medium text-gray-700 dark:text-gray-300">å»ºç«‹æ—¥æœŸï¼š</span>
                        <span class="text-gray-900 dark:text-white">${createdDate}</span>
                    </div>
                    
                    <div class="flex justify-between">
                        <span class="font-medium text-gray-700 dark:text-gray-300">ä¾†æºï¼š</span>
                        <span class="text-gray-900 dark:text-white">${playlist.imported ? 'å¾YouTubeåŒ¯å…¥' : 'æœ¬åœ°å»ºç«‹'}</span>
                    </div>
                    
                    ${playlist.duplicatedFrom ? `
                        <div class="flex justify-between">
                            <span class="font-medium text-gray-700 dark:text-gray-300">è¤‡è£½è‡ªï¼š</span>
                            <span class="text-gray-900 dark:text-white">${playlist.duplicatedFrom}</span>
                        </div>
                    ` : ''}
                </div>
                
                <div class="mb-4">
                    <label class="block font-medium text-gray-700 dark:text-gray-300 mb-2">
                        ğŸ“ å‚™è¨»ï¼š
                    </label>
                    <textarea 
                        id="playlistRemarks" 
                        placeholder="æ·»åŠ é—œæ–¼é€™å€‹æ’­æ”¾æ¸…å–®çš„å‚™è¨»Â·Â·Â·"
                        class="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-white resize-vertical"
                        rows="4"
                        style="min-height: 80px; max-height: 200px;"
                    >${remarks}</textarea>
                    <div class="text-xs text-gray-500 dark:text-gray-400 mt-1">
                        ä½¿ç”¨æ­¤ç©ºé–“æ–°å¢æœ‰é—œæ­¤æ’­æ”¾æ¸…å–®çš„å€‹äººç­†è¨˜ã€æè¿°æˆ–æé†’ã€‚
                    </div>
                </div>
                
                <div class="flex gap-3 justify-end">
                    <button 
                        onclick="hidePlaylistInfo()" 
                        class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
                    >
                        å–æ¶ˆ
                    </button>
                    <button 
                        onclick="savePlaylistRemarks('${escapeHtml(playlistName)}')" 
                        class="px-4 py-2 bg-primary text-white rounded hover:bg-opacity-90 transition-colors"
                    >
                        ğŸ’¾ å„²å­˜
                    </button>
                </div>
            `;
            
            overlay.appendChild(form);
            document.body.appendChild(overlay);
            
            // Focus the textarea
            const textarea = document.getElementById('playlistRemarks');
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length); // Move cursor to end
            
            // Handle keyboard shortcuts
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    hidePlaylistInfo();
                } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    // Ctrl+Enter or Cmd+Enter to save
                    savePlaylistRemarks(playlistName);
                }
            });
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hidePlaylistInfo();
                }
            });
        }

        function hidePlaylistInfo() {
            const overlay = document.getElementById('playlistInfoOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        function savePlaylistRemarks(playlistName) {
            const textarea = document.getElementById('playlistRemarks');
            const remarks = textarea.value.trim();
            
            // Save remarks to playlist
            playlists[playlistName].remarks = remarks;
            
            saveSettings();
            hidePlaylistInfo();
            
            // Show brief success feedback
            const feedback = document.createElement('div');
            feedback.className = 'fixed top-4 right-4 bg-green-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 transition-opacity';
            feedback.textContent = 'âœ… å·²ä¿å­˜å‚™è¨»ï¼';
            document.body.appendChild(feedback);
            
            // Auto-remove feedback after 2 seconds
            setTimeout(() => {
                feedback.style.opacity = '0';
                setTimeout(() => feedback.remove(), 300);
            }, 2000);
        }

        // Drag and Drop Functions
        function handleDragStart(event, index) {
            if (isSelectionMode) {
                event.preventDefault();
                return;
            }
            
            draggedIndex = index;
            draggedElement = event.target;
            
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/html', event.target.outerHTML);
        }

        function handleDragOver(event) {
            if (isSelectionMode || draggedIndex === null) return;
            
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            
            const rect = event.target.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            
            if (event.clientY < midpoint) {
                event.target.classList.add('drag-over');
            } else {
                event.target.classList.remove('drag-over');
            }
        }

        function handleDrop(event, dropIndex) {
            if (isSelectionMode || draggedIndex === null) return;
            
            event.preventDefault();
            
            if (draggedIndex === dropIndex) return;
            
            const videos = playlists[currentPlaylist].videos;
            const draggedVideo = videos[draggedIndex];
            
            // Remove dragged video
            videos.splice(draggedIndex, 1);
            
            // Adjust drop index if needed
            if (draggedIndex < dropIndex) {
                dropIndex--;
            }
            
            // Insert at new position
            videos.splice(dropIndex, 0, draggedVideo);
            
            // Update current video index if needed
            if (currentVideoIndex === draggedIndex) {
                currentVideoIndex = dropIndex;
            } else if (currentVideoIndex > draggedIndex && currentVideoIndex <= dropIndex) {
                currentVideoIndex--;
            } else if (currentVideoIndex < draggedIndex && currentVideoIndex >= dropIndex) {
                currentVideoIndex++;
            }
            
            saveSettings();
            renderCurrentPlaylist();
        }

        function handleDragEnd(event) {
            if (draggedElement) {
                draggedElement.classList.remove('dragging');
            }
            
            // Remove all drag-over classes
            document.querySelectorAll('.drag-over').forEach(el => {
                el.classList.remove('drag-over');
            });
            
            draggedIndex = null;
            draggedElement = null;
        }

        // Selection Mode Functions
        function toggleSelectionMode() {
            isSelectionMode = !isSelectionMode;
            selectedVideos.clear();
            
            const container = document.getElementById('currentPlaylistVideos');
            const button = document.getElementById('playlistSelectButton');
            const controls = document.getElementById('selectionControls');
            
            if (isSelectionMode) {
                container.classList.add('selection-mode');
                button.textContent = 'å®Œæˆ';
                button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                button.classList.add('bg-red-600', 'hover:bg-red-700');
                controls.classList.remove('hidden');
            } else {
                container.classList.remove('selection-mode');
                button.textContent = 'é¸æ“‡';
                button.classList.remove('bg-red-600', 'hover:bg-red-700');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700');
                controls.classList.add('hidden');
            }
            
            renderCurrentPlaylist();
            updateSelectedCount();
        }

        function toggleVideoSelection(index) {
            if (!isSelectionMode) return;
            
            const checkbox = document.querySelector(`input[data-index="${index}"]`);
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                updateSelectedCount();
            }
        }

        function updateSelectedCount() {
            if (!isSelectionMode) return;
            
            const checkboxes = document.querySelectorAll('.video-checkbox:checked');
            selectedVideos = new Set(Array.from(checkboxes).map(cb => parseInt(cb.dataset.index)));
            
            const countElement = document.getElementById('selectedCount');
            if (countElement) {
                countElement.textContent = selectedVideos.size;
            }
        }

        function selectAllVideos() {
            const checkboxes = document.querySelectorAll('.video-checkbox');
            checkboxes.forEach(cb => cb.checked = true);
            updateSelectedCount();
        }

        function deselectAllVideos() {
            const checkboxes = document.querySelectorAll('.video-checkbox');
            checkboxes.forEach(cb => cb.checked = false);
            updateSelectedCount();
        }

        // Bulk Operations
        function moveSelectedVideos() {
            if (selectedVideos.size === 0) {
                alert('Please select videos to move');
                return;
            }
            
            const playlistNames = Object.keys(playlists).filter(name => name !== currentPlaylist);
            
            if (playlistNames.length === 0) {
                alert('No other playlists available');
                return;
            }
            
            showMoveVideosDialog();
        }

        function copySelectedVideos() {
            if (selectedVideos.size === 0) {
                alert('Please select videos to copy');
                return;
            }
            
            const playlistNames = Object.keys(playlists).filter(name => name !== currentPlaylist);
            
            if (playlistNames.length === 0) {
                alert('No other playlists available');
                return;
            }
            
            showCopyVideosDialog();
        }

        // Move Videos Dialog
        function showMoveVideosDialog() {
            const playlistNames = Object.keys(playlists).filter(name => name !== currentPlaylist);
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'moveVideosOverlay';
            
            const form = document.createElement('div');
            form.className = 'rename-form';
            form.style.minWidth = '350px';
            
            form.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">Move Videos</h3>
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                    ç§»å‹•${selectedVideos.size}æ¢å·²é¸æ“‡å½±ç‰‡è‡³ï¼š
                </p>
                <div class="max-h-64 overflow-y-auto mb-4 space-y-2">
                    ${playlistNames.map(name => `
                        <label class="flex items-center gap-3 p-3 hover:bg-gray-100 dark:hover:bg-gray-600 rounded cursor-pointer border border-gray-200 dark:border-gray-600">
                            <input type="radio" name="targetPlaylist" value="${escapeHtml(name)}" class="move-radio">
                            <div class="flex-1">
                                <div class="font-medium">${name}</div>
                                <div class="text-sm text-gray-600 dark:text-gray-400">${playlists[name].videos.length}æ¢å½±ç‰‡</div>
                            </div>
                        </label>
                    `).join('')}
                </div>
                <div class="flex gap-3 justify-end">
                    <button 
                        onclick="hideMoveVideosDialog()" 
                        class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
                    >
                        å–æ¶ˆ
                    </button>
                    <button 
                        onclick="confirmMoveVideos()" 
                        class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition-colors"
                    >
                        ğŸ“ ç§»å‹•å½±ç‰‡
                    </button>
                </div>
            `;
            
            overlay.appendChild(form);
            document.body.appendChild(overlay);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hideMoveVideosDialog();
                }
            });
        }

        function hideMoveVideosDialog() {
            const overlay = document.getElementById('moveVideosOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        function confirmMoveVideos() {
            const selectedRadio = document.querySelector('input[name="targetPlaylist"]:checked');
            
            if (!selectedRadio) {
                alert('Please select a playlist');
                return;
            }
            
            const targetPlaylist = selectedRadio.value;
            
            const currentVideos = playlists[currentPlaylist].videos;
            const selectedIndices = Array.from(selectedVideos).sort((a, b) => b - a); // Sort descending
            const videosToMove = [];
            
            // Remove selected videos (in reverse order to maintain indices)
            selectedIndices.forEach(index => {
                videosToMove.push(currentVideos[index]);
                currentVideos.splice(index, 1);
            });
            
            // Add to target playlist
            playlists[targetPlaylist].videos.push(...videosToMove.reverse());
            
            // Adjust current video index
            let adjustment = 0;
            selectedIndices.forEach(index => {
                if (index <= currentVideoIndex) {
                    adjustment++;
                }
            });
            currentVideoIndex = Math.max(0, currentVideoIndex - adjustment);
            
            saveSettings();
            renderPlaylists();
            renderCurrentPlaylist();
            selectedVideos.clear();
            updateSelectedCount();
            hideMoveVideosDialog();
            
            alert(`Moved ${videosToMove.length} videos to "${targetPlaylist}"`);
        }

        // Copy Videos Dialog
        function showCopyVideosDialog() {
            const playlistNames = Object.keys(playlists).filter(name => name !== currentPlaylist);
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'copyVideosOverlay';
            
            const form = document.createElement('div');
            form.className = 'rename-form';
            form.style.minWidth = '350px';
            
            form.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">Copy Videos</h3>
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                    Select playlist to copy ${selectedVideos.size} selected videos to:
                </p>
                <div class="max-h-64 overflow-y-auto mb-4 space-y-2">
                    ${playlistNames.map(name => `
                        <label class="flex items-center gap-3 p-3 hover:bg-gray-100 dark:hover:bg-gray-600 rounded cursor-pointer border border-gray-200 dark:border-gray-600">
                            <input type="radio" name="targetPlaylist" value="${escapeHtml(name)}" class="copy-radio">
                            <div class="flex-1">
                                <div class="font-medium">${name}</div>
                                <div class="text-sm text-gray-600 dark:text-gray-400">${playlists[name].videos.length} videos</div>
                            </div>
                        </label>
                    `).join('')}
                </div>
                <div class="flex gap-3 justify-end">
                    <button 
                        onclick="hideCopyVideosDialog()" 
                        class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
                    >
                        å–æ¶ˆ
                    </button>
                    <button 
                        onclick="confirmCopyVideos()" 
                        class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
                    >
                        ğŸ“‹ Copy Videos
                    </button>
                </div>
            `;
            
            overlay.appendChild(form);
            document.body.appendChild(overlay);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hideCopyVideosDialog();
                }
            });
        }

        function hideCopyVideosDialog() {
            const overlay = document.getElementById('copyVideosOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        function confirmCopyVideos() {
            const selectedRadio = document.querySelector('input[name="targetPlaylist"]:checked');
            
            if (!selectedRadio) {
                alert('Please select a playlist');
                return;
            }
            
            const targetPlaylist = selectedRadio.value;
            
            const currentVideos = playlists[currentPlaylist].videos;
            const videosToCopy = Array.from(selectedVideos).map(index => ({ ...currentVideos[index] }));
            
            // Add to target playlist (filter duplicates)
            const existingIds = new Set(playlists[targetPlaylist].videos.map(v => v.id));
            const newVideos = videosToCopy.filter(video => !existingIds.has(video.id));
            
            playlists[targetPlaylist].videos.push(...newVideos);
            
            saveSettings();
            renderPlaylists();
            selectedVideos.clear();
            updateSelectedCount();
            hideCopyVideosDialog();
            
            if (newVideos.length < videosToCopy.length) {
                alert(`Copied ${newVideos.length} videos to "${targetPlaylist}" (${videosToCopy.length - newVideos.length} duplicates skipped)`);
            } else {
                alert(`Copied ${newVideos.length} videos to "${targetPlaylist}"`);
            }
        }

        function deleteSelectedVideos() {
            if (selectedVideos.size === 0) {
                alert('Please select videos to delete');
                return;
            }
            
            if (!confirm(`Delete ${selectedVideos.size} selected videos?`)) {
                return;
            }
            
            const currentVideos = playlists[currentPlaylist].videos;
            const selectedIndices = Array.from(selectedVideos).sort((a, b) => b - a); // Sort descending
            
            // Remove selected videos (in reverse order to maintain indices)
            selectedIndices.forEach(index => {
                currentVideos.splice(index, 1);
            });
            
            // Adjust current video index
            let adjustment = 0;
            selectedIndices.forEach(index => {
                if (index <= currentVideoIndex) {
                    adjustment++;
                }
            });
            currentVideoIndex = Math.max(0, currentVideoIndex - adjustment);
            
            saveSettings();
            renderPlaylists();
            renderCurrentPlaylist();
            selectedVideos.clear();
            updateSelectedCount();
        }

        // Enhanced Touch Support for Video Items (Drag and Drop on Mobile)
        let videoDragData = {
            isDragging: false,
            startPos: { x: 0, y: 0 },
            currentIndex: -1,
            dragElement: null,
            dragThreshold: 15
        };

        function handleVideoTouchStart(event, index) {
            if (isSelectionMode) return;
            
            // Store initial touch data
            videoDragData.startPos = {
                x: event.touches[0].clientX,
                y: event.touches[0].clientY
            };
            videoDragData.currentIndex = index;
            videoDragData.dragElement = event.target.closest('.playlist-video-item');
            videoDragData.isDragging = false;
            
            // Prevent text selection
            event.preventDefault();
            
            // Add touch feedback
            videoDragData.dragElement?.classList.add('touch-active');
        }

        function handleVideoTouchMove(event, index) {
            if (isSelectionMode || videoDragData.currentIndex !== index) return;
            
            event.preventDefault(); // Prevent scrolling while dragging
            
            const currentPos = {
                x: event.touches[0].clientX,
                y: event.touches[0].clientY
            };
            
            const distance = Math.sqrt(
                Math.pow(currentPos.x - videoDragData.startPos.x, 2) +
                Math.pow(currentPos.y - videoDragData.startPos.y, 2)
            );
            
            // Start dragging if moved beyond threshold
            if (!videoDragData.isDragging && distance > videoDragData.dragThreshold) {
                videoDragData.isDragging = true;
                
                // Add dragging visual feedback
                videoDragData.dragElement?.classList.add('dragging');
                videoDragData.dragElement?.classList.remove('touch-active');
                
                // Add haptic feedback if available
                if (navigator.vibrate) {
                    navigator.vibrate(30);
                }
            }
            
            if (videoDragData.isDragging) {
                // Find the element under the touch point
                const elementBelow = document.elementFromPoint(currentPos.x, currentPos.y);
                const videoItemBelow = elementBelow?.closest('.playlist-video-item');
                
                // Remove drag-over class from all items
                document.querySelectorAll('.playlist-video-item').forEach(item => {
                    item.classList.remove('drag-over');
                });
                
                // Add drag-over class to target item
                if (videoItemBelow && videoItemBelow !== videoDragData.dragElement) {
                    videoItemBelow.classList.add('drag-over');
                }
            }
        }

        function handleVideoTouchEnd(event, index) {
            videoDragData.dragElement?.classList.remove('touch-active');
            
            if (videoDragData.isDragging && videoDragData.currentIndex === index) {
                // Find the drop target
                const lastTouchPos = {
                    x: event.changedTouches[0].clientX,
                    y: event.changedTouches[0].clientY
                };
                
                const elementBelow = document.elementFromPoint(lastTouchPos.x, lastTouchPos.y);
                const dropTarget = elementBelow?.closest('.playlist-video-item');
                
                if (dropTarget && dropTarget !== videoDragData.dragElement) {
                    const dropIndex = parseInt(dropTarget.dataset.index);
                    
                    if (!isNaN(dropIndex) && dropIndex !== index) {
                        // Perform the move operation
                        performVideoMove(index, dropIndex);
                        
                        // Add haptic feedback for successful drop
                        if (navigator.vibrate) {
                            navigator.vibrate([50, 30, 50]);
                        }
                    }
                }
                
                // Clean up dragging state
                videoDragData.dragElement?.classList.remove('dragging');
                document.querySelectorAll('.drag-over').forEach(el => {
                    el.classList.remove('drag-over');
                });
            }
            
            // Reset drag data
            videoDragData = {
                isDragging: false,
                startPos: { x: 0, y: 0 },
                currentIndex: -1,
                dragElement: null,
                dragThreshold: 15
            };
        }

        function performVideoMove(fromIndex, toIndex) {
            if (!currentPlaylist || fromIndex === toIndex) return;
            
            const videos = playlists[currentPlaylist].videos;
            const movedVideo = videos[fromIndex];
            
            // Remove the video from its current position
            videos.splice(fromIndex, 1);
            
            // Adjust the target index if needed
            let targetIndex = toIndex;
            if (fromIndex < toIndex) {
                targetIndex--;
            }
            
            // Insert the video at the new position
            videos.splice(targetIndex, 0, movedVideo);
            
            // Update current video index if needed
            if (currentVideoIndex === fromIndex) {
                currentVideoIndex = targetIndex;
            } else if (currentVideoIndex > fromIndex && currentVideoIndex <= toIndex) {
                currentVideoIndex--;
            } else if (currentVideoIndex < fromIndex && currentVideoIndex >= targetIndex) {
                currentVideoIndex++;
            }
            
            saveSettings();
            renderCurrentPlaylist();
        }

        // Format date helper
        function formatDate(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffTime = Math.abs(now - date);
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            
            if (diffDays === 0) return 'Today';
            if (diffDays === 1) return 'Yesterday';
            if (diffDays < 30) return `${diffDays} days ago`;
            if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
            return `${Math.floor(diffDays / 365)} years ago`;
        }

        // Export/Import Playlist Functions
        function exportPlaylist(playlistName) {
            if (!playlists[playlistName]) {
                alert('Playlist not found!');
                return;
            }

            const playlist = playlists[playlistName];
            
            // Create export data with metadata
            const exportData = {
                name: playlist.name,
                videos: playlist.videos,
                created: playlist.created,
                exported: new Date().toISOString(),
                version: "1.0",
                source: "YouTube Player by Nut",
                remarks: playlist.remarks || '',
                imported: playlist.imported || false,
                duplicatedFrom: playlist.duplicatedFrom || null,
                totalVideos: playlist.videos.length,
                metadata: {
                    exportedBy: "YouTube Player",
                    format: "JSON",
                    compatible: ["YouTube Player v1.0+"]
                }
            };

            // Convert to JSON string
            const jsonString = JSON.stringify(exportData, null, 2);
            
            // Create blob and download
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // Create download link
            const link = document.createElement('a');
            link.href = url;
            link.download = `${playlistName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_playlist.json`;
            
            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Clean up blob URL
            URL.revokeObjectURL(url);
            
            // Show success message
            showSuccessMessage(`âœ… Playlist "${playlistName}" exported successfully!`);
        }

        function showImportPlaylistDialog() {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'importPlaylistOverlay';
            
            const form = document.createElement('div');
            form.className = 'rename-form';
            form.style.minWidth = '400px';
            form.style.maxWidth = '500px';
            
            form.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">ğŸ“¥åŒ¯å…¥æ’­æ”¾æ¸…å–®</h3>
                
                <div class="mb-4">
                    <p class="text-sm text-gray-600 dark:text-gray-400 mb-3">
                        é¸æ“‡è¦åŒ¯å…¥çš„æ’­æ”¾æ¸…å–®æª”æ¡ˆï¼ˆJSONæ ¼å¼ï¼‰ï¼š
                    </p>
                    <div class="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-6 text-center">
                        <input 
                            type="file" 
                            id="playlistFileInput" 
                            accept=".json"
                            class="hidden"
                            onchange="handlePlaylistFileSelect(event)"
                        >
                        <label 
                            for="playlistFileInput" 
                            class="cursor-pointer flex flex-col items-center gap-2 text-gray-600 dark:text-gray-400 hover:text-primary transition-colors"
                        >
                            <div class="text-4xl">ğŸ“</div>
                            <div class="font-medium">é¸æ“‡æª”æ¡ˆ</div>
                            <div class="text-xs">æˆ–è€…åœ¨é€™è£¡æ‹–æ”¾</div>
                        </label>
                    </div>
                    <div class="text-xs text-gray-500 dark:text-gray-400 mt-2">
                        æ”¯æ´çš„æ ¼å¼ï¼šå¾YouTubeæ’­æ”¾å™¨åŒ¯å‡ºçš„JSONæª”æ¡ˆ
                    </div>
                </div>
                
                <div id="importPreview" class="hidden mb-4 p-3 bg-gray-50 dark:bg-gray-700 rounded border">
                    <h4 class="font-medium mb-2 text-gray-900 dark:text-white">Preview:</h4>
                    <div id="importDetails" class="text-sm text-gray-600 dark:text-gray-400"></div>
                </div>
                
                <div class="flex gap-3 justify-end">
                    <button 
                        onclick="hideImportPlaylistDialog()" 
                        class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
                    >
                        å–æ¶ˆ
                    </button>
                    <button 
                        id="confirmImportBtn"
                        onclick="confirmImportPlaylist()" 
                        class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                        disabled
                    >
                        ğŸ“¥åŒ¯å…¥æ’­æ”¾æ¸…å–®
                    </button>
                </div>
            `;
            
            overlay.appendChild(form);
            document.body.appendChild(overlay);
            
            // Set up drag and drop
            const dropZone = form.querySelector('label[for="playlistFileInput"]').parentElement;
            
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('border-primary', 'bg-blue-50', 'dark:bg-blue-900');
            });
            
            dropZone.addEventListener('dragleave', (e) => {
                if (!dropZone.contains(e.relatedTarget)) {
                    dropZone.classList.remove('border-primary', 'bg-blue-50', 'dark:bg-blue-900');
                }
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('border-primary', 'bg-blue-50', 'dark:bg-blue-900');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handlePlaylistFile(files[0]);
                }
            });
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hideImportPlaylistDialog();
                }
            });
        }

        function hideImportPlaylistDialog() {
            const overlay = document.getElementById('importPlaylistOverlay');
            if (overlay) {
                overlay.remove();
            }
            // Clear the stored import data
            window.importPlaylistData = null;
        }

        function handlePlaylistFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                handlePlaylistFile(file);
            }
        }

        function handlePlaylistFile(file) {
            if (!file) return;
            
            // Check file type
            if (!file.name.toLowerCase().endsWith('.json')) {
                alert('è«‹é¸æ“‡JSONæª”æ¡ˆã€‚');
                return;
            }
            
            // Check file size (max 10MB)
            if (file.size > 10 * 1024 * 1024) {
                alert('æª”æ¡ˆå¤ªå¤§äº†ï¼Œæœ€å¤§å¤§å°ç‚º10MBã€‚');
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const importData = JSON.parse(e.target.result);
                    validateAndPreviewPlaylist(importData);
                } catch (error) {
                    console.error('Error parsing playlist file:', error);
                    alert('JSONæª”æ¡ˆç„¡æ•ˆï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ ¼å¼ã€‚');
                }
            };
            
            reader.onerror = function() {
                alert('è®€å–æª”æ¡ˆæ™‚å‡ºéŒ¯ï¼Œè«‹é‡è©¦ã€‚');
            };
            
            reader.readAsText(file);
        }

        function validateAndPreviewPlaylist(data) {
            // Validate required fields
            if (!data.name || !Array.isArray(data.videos)) {
                alert('æ’­æ”¾åˆ—è¡¨æ ¼å¼ç„¡æ•ˆï¼Œç¼ºå°‘å¿…å¡«æ¬„ä½ï¼ˆåç¨±ã€å½±ç‰‡ï¼‰ã€‚');
                return;
            }
            
            // Validate videos structure
            const validVideos = data.videos.filter(video => 
                video && 
                typeof video === 'object' && 
                video.id && 
                video.title && 
                video.channel
            );
            
            if (validVideos.length === 0) {
                alert('åœ¨æ’­æ”¾æ¸…å–®ä¸­æ²’æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„å½±ç‰‡ã€‚');
                return;
            }
            
            // Store the validated data
            window.importPlaylistData = {
                ...data,
                videos: validVideos
            };
            
            // Show preview
            const preview = document.getElementById('importPreview');
            const details = document.getElementById('importDetails');
            
            const created = data.created ? new Date(data.created).toLocaleDateString() : 'æœªçŸ¥';
            const exported = data.exported ? new Date(data.exported).toLocaleDateString() : 'æœªçŸ¥';
            const source = data.source || 'æœªçŸ¥';
            
            details.innerHTML = `
                <div class="space-y-1">
                    <div><strong>åç¨±ï¼š</strong> ${data.name}</div>
                    <div><strong>å½±ç‰‡ï¼š</strong> ${validVideos.length} ${data.totalVideos && data.totalVideos !== validVideos.length ? `(${data.totalVideos - validVideos.length} invalid videos filtered)` : ''}</div>
                    <div><strong>å»ºç«‹æ—¥æœŸï¼š</strong> ${created}</div>
                    <div><strong>åŒ¯å‡ºæ—¥æœŸï¼š</strong> ${exported}</div>
                    <div><strong>ä¾†æºï¼š</strong> ${source}</div>
                    ${data.remarks ? `<div><strong>å‚™è¨»ï¼š</strong>${data.remarks}</div>` : ''}
                </div>
            `;
            
            preview.classList.remove('hidden');
            
            // Enable import button
            document.getElementById('confirmImportBtn').disabled = false;
        }

        function confirmImportPlaylist() {
            if (!window.importPlaylistData) {
                alert('No playlist data to import.');
                return;
            }
            
            const data = window.importPlaylistData;
            let finalName = data.name;
            
            // Handle name conflicts
            if (playlists[finalName]) {
                const choice = confirm(`åå­—å«ã€Œ${finalName}ã€çš„æ’­æ”¾æ¸…å–®å·²ç¶“å­˜åœ¨äº†ã€‚æ‚¨æƒ³è¦å¦‚ä½•è™•ç†ï¼š\n\nç¢ºå®š - å–ä»£ç¾æœ‰æ’­æ”¾æ¸…å–®\nå–æ¶ˆ - ç”¨ä¸åŒçš„åå­—å»ºç«‹`);
                
                if (!choice) {
                    // Generate a unique name
                    let counter = 1;
                    while (playlists[`${finalName} (${counter})`]) {
                        counter++;
                    }
                    finalName = `${finalName} (${counter})`;
                }
            }
            
            // Create the playlist
            playlists[finalName] = {
                name: finalName,
                videos: data.videos,
                created: data.created || new Date().toISOString(),
                imported: true,
                importedFrom: data.source || 'å¤–éƒ¨ä¾†æº',
                remarks: data.remarks || '',
                originalName: data.name !== finalName ? data.name : undefined
            };
            
            // Save and update UI
            saveSettings();
            renderPlaylists();
            hideImportPlaylistDialog();
            
            // Show success message
            showSuccessMessage(`âœ…æˆåŠŸåŒ¯å…¥ã€Œ${finalName}ã€ï¼Œå…±${data.videos.length}éƒ¨å½±ç‰‡ï¼`);
            
            // Automatically load the imported playlist
            setTimeout(() => {
                loadPlaylist(finalName);
            }, 500);
        }

        function showSuccessMessage(message) {
            const feedback = document.createElement('div');
            feedback.className = 'fixed top-4 right-4 bg-green-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 transition-opacity max-w-sm';
            feedback.textContent = message;
            document.body.appendChild(feedback);
            
            // Auto-remove feedback after 3 seconds
            setTimeout(() => {
                feedback.style.opacity = '0';
                setTimeout(() => feedback.remove(), 300);
            }, 3000);
        }

        // Import Progress Functions (for YouTube playlist import without clearing search results)
        function showImportProgress(playlistTitle) {
            // Create floating progress indicator
            const progressIndicator = document.createElement('div');
            progressIndicator.id = 'importProgressIndicator';
            progressIndicator.className = 'fixed top-4 left-4 bg-blue-600 text-white px-4 py-3 rounded-lg shadow-lg z-50 flex items-center gap-3 max-w-sm';
            progressIndicator.innerHTML = `
                <div class="animate-spin inline-block w-5 h-5 border-2 border-current border-t-transparent rounded-full"></div>
                <div>
                    <div class="font-medium">æ­£åœ¨åŒ¯å…¥ã€Œ${playlistTitle}ã€</div>
                    <div class="text-sm opacity-90" id="importProgressText">é–‹å§‹åŒ¯å…¥ä¸­Â·Â·Â·</div>
                </div>
            `;
            document.body.appendChild(progressIndicator);
        }

        function updateImportProgress(message) {
            const progressText = document.getElementById('importProgressText');
            if (progressText) {
                progressText.textContent = message;
            }
        }

        function hideImportProgress() {
            const progressIndicator = document.getElementById('importProgressIndicator');
            if (progressIndicator) {
                progressIndicator.remove();
            }
        }

        function showImportSuccessMessage(message) {
            const feedback = document.createElement('div');
            feedback.className = 'fixed top-4 left-4 bg-green-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 transition-opacity max-w-sm';
            feedback.textContent = message;
            document.body.appendChild(feedback);
            
            // Auto-remove feedback after 3 seconds
            setTimeout(() => {
                feedback.style.opacity = '0';
                setTimeout(() => feedback.remove(), 300);
            }, 3000);
        }

        function showImportErrorMessage(message) {
            const feedback = document.createElement('div');
            feedback.className = 'fixed top-4 left-4 bg-red-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 transition-opacity max-w-sm';
            feedback.textContent = message;
            document.body.appendChild(feedback);
            
            // Auto-remove feedback after 5 seconds (longer for errors)
            setTimeout(() => {
                feedback.style.opacity = '0';
                setTimeout(() => feedback.remove(), 300);
            }, 5000);
        }

        // Other Menu Functions (Info + Export + Search combined)
        function showOtherMenu(playlistName, buttonElement) {
            // Remove any existing dropdown
            const existingDropdown = document.querySelector('.other-dropdown');
            if (existingDropdown) {
                existingDropdown.remove();
            }
            
            // Create dropdown menu
            const dropdown = document.createElement('div');
            dropdown.className = 'other-dropdown fixed bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg shadow-xl py-2 min-w-40 z-50';
            
            // Add menu items
            dropdown.innerHTML = `
                <div class="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 border-b border-gray-200 dark:border-gray-600">
                    æ›´å¤šé¸é …
                </div>
                <div 
                    onclick="showVideoSearchDialog('${escapeHtml(playlistName)}'); hideOtherMenu();" 
                    class="px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-600 cursor-pointer transition-colors flex items-center gap-2"
                >
                    <span>ğŸ”</span>
                    <span>æœå°‹å½±ç‰‡</span>
                </div>
                <div 
                    onclick="showPlaylistInfo('${escapeHtml(playlistName)}'); hideOtherMenu();" 
                    class="px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-600 cursor-pointer transition-colors flex items-center gap-2"
                >
                    <span>ğŸ“Š</span>
                    <span>æ¸…å–®è³‡è¨Š</span>
                </div>
                <div 
                    onclick="exportPlaylist('${escapeHtml(playlistName)}'); hideOtherMenu();" 
                    class="px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-600 cursor-pointer transition-colors flex items-center gap-2"
                >
                    <span>ğŸ“¤</span>
                    <span>åŒ¯å‡ºæ¸…å–®</span>
                </div>
            `;
            
            // Position dropdown using fixed positioning
            const buttonRect = buttonElement.getBoundingClientRect();
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;
            
            // Calculate position
            let top = buttonRect.bottom + 4;
            let left = buttonRect.left;
            
            // Adjust if dropdown would go off-screen
            const dropdownHeight = 120; // Estimate height
            const dropdownWidth = 160; // min-w-40 = 160px
            
            // Adjust vertical position if it goes below viewport
            if (top + dropdownHeight > viewportHeight) {
                top = buttonRect.top - dropdownHeight - 4;
            }
            
            // Adjust horizontal position if it goes off right edge
            if (left + dropdownWidth > viewportWidth) {
                left = viewportWidth - dropdownWidth - 10;
            }
            
            // Ensure it doesn't go off left edge
            if (left < 10) {
                left = 10;
            }
            
            dropdown.style.top = top + 'px';
            dropdown.style.left = left + 'px';
            
            // Append to body for better positioning
            document.body.appendChild(dropdown);
            
            // Close dropdown when clicking outside
            const closeDropdown = (e) => {
                if (!dropdown.contains(e.target) && e.target !== buttonElement) {
                    dropdown.remove();
                    document.removeEventListener('click', closeDropdown);
                }
            };
            
            // Add event listener after a small delay to prevent immediate closure
            setTimeout(() => {
                document.addEventListener('click', closeDropdown);
            }, 100);
        }

        function hideOtherMenu() {
            const dropdown = document.querySelector('.other-dropdown');
            if (dropdown) {
                dropdown.remove();
            }
        }

        // Video Search in Playlist Functions
        function showVideoSearchDialog(playlistName) {
            if (!playlists[playlistName]) {
                alert('Playlist not found!');
                return;
            }
            
            const playlist = playlists[playlistName];
            if (playlist.videos.length === 0) {
                alert('é€™å€‹æ’­æ”¾æ¸…å–®æ˜¯ç©ºçš„ï¼Œæ²’æœ‰å½±ç‰‡å¯ä»¥æœå°‹ã€‚');
                return;
            }
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'videoSearchOverlay';
            
            const modal = document.createElement('div');
            modal.className = 'rename-form';
            modal.style.maxHeight = '80vh';
            modal.style.display = 'flex';
            modal.style.flexDirection = 'column';
            
            // Responsive width handling
            if (window.innerWidth <= 640) {
                modal.style.minWidth = 'calc(100vw - 32px)';
                modal.style.maxWidth = 'calc(100vw - 32px)';
                modal.style.width = 'calc(100vw - 32px)';
            } else {
                modal.style.minWidth = '500px';
                modal.style.maxWidth = '600px';
            }
            
            modal.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">ğŸ” åœ¨ã€Œ${playlistName}ã€ä¸­æœå°‹å½±ç‰‡</h3>
                
                <div class="mb-4">
                    <input 
                        type="text" 
                        id="videoSearchInput" 
                        placeholder="æŒ‰å½±ç‰‡æ¨™é¡Œæˆ–é »é“åç¨±æœå°‹Â·Â·Â·"
                        class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:ring-2 focus:ring-primary focus:border-transparent"
                    >
                    <div class="text-xs text-gray-500 dark:text-gray-400 mt-1">
                        åœ¨${playlist.videos.length}éƒ¨å½±ç‰‡ä¸­å°‹æ‰¾ â€¢ è¼¸å…¥å³å¯ç«‹å³æ‰¾åˆ°å½±ç‰‡
                    </div>
                </div>
                
                <div id="videoSearchResults" class="flex-1 min-h-0 mb-4">
                    <div id="videoSearchEmptyState" class="text-center py-8 text-gray-500 dark:text-gray-400">
                        <div class="text-4xl mb-2">ğŸ¬</div>
                        <div>é–‹å§‹è¼¸å…¥ä»¥æœå°‹æ‚¨çš„å½±ç‰‡</div>
                    </div>
                    
                    <div id="videoSearchResultsList" class="hidden max-h-96 overflow-y-auto space-y-2">
                        <!-- Search results will appear here -->
                    </div>
                    
                    <div id="videoSearchNoResults" class="hidden text-center py-8 text-gray-500 dark:text-gray-400">
                        <div class="text-4xl mb-2">ğŸ”</div>
                        <div>æœªæ‰¾åˆ°èˆ‡æ‚¨çš„æœå°‹åŒ¹é…çš„å½±ç‰‡</div>
                        <div class="text-sm mt-1">è«‹å˜—è©¦ä¸åŒçš„é—œéµå­—</div>
                    </div>
                </div>
                
                <div class="flex gap-3 justify-end">
                    <button 
                        onclick="hideVideoSearchDialog()" 
                        class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
                    >
                        é—œé–‰
                    </button>
                </div>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // Focus the search input
            const searchInput = document.getElementById('videoSearchInput');
            searchInput.focus();
            
            // Set up search functionality
            let searchTimeout;
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                const query = e.target.value.trim();
                
                if (query === '') {
                    showVideoSearchEmptyState();
                    return;
                }
                
                // Debounce search to avoid excessive filtering
                searchTimeout = setTimeout(() => {
                    performVideoSearch(playlistName, query);
                }, 300);
            });
            
            // Handle keyboard shortcuts
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    hideVideoSearchDialog();
                } else if (e.key === 'Enter') {
                    // Focus first result if available
                    const firstResult = document.querySelector('.video-search-result');
                    if (firstResult) {
                        firstResult.click();
                    }
                }
            });
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hideVideoSearchDialog();
                }
            });
        }

        function hideVideoSearchDialog() {
            const overlay = document.getElementById('videoSearchOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        function showVideoSearchEmptyState() {
            document.getElementById('videoSearchEmptyState').classList.remove('hidden');
            document.getElementById('videoSearchResultsList').classList.add('hidden');
            document.getElementById('videoSearchNoResults').classList.add('hidden');
        }

        function showVideoSearchResults() {
            document.getElementById('videoSearchEmptyState').classList.add('hidden');
            document.getElementById('videoSearchResultsList').classList.remove('hidden');
            document.getElementById('videoSearchNoResults').classList.add('hidden');
        }

        function showVideoSearchNoResults() {
            document.getElementById('videoSearchEmptyState').classList.add('hidden');
            document.getElementById('videoSearchResultsList').classList.add('hidden');
            document.getElementById('videoSearchNoResults').classList.remove('hidden');
        }

        function performVideoSearch(playlistName, query) {
            const playlist = playlists[playlistName];
            if (!playlist) return;
            
            const queryLower = query.toLowerCase();
            const matchingVideos = [];
            
            // Search through videos
            playlist.videos.forEach((video, index) => {
                const titleMatch = video.title.toLowerCase().includes(queryLower);
                const channelMatch = video.channel.toLowerCase().includes(queryLower);
                
                if (titleMatch || channelMatch) {
                    matchingVideos.push({
                        ...video,
                        index: index,
                        titleHighlight: highlightSearchTerms(video.title, query),
                        channelHighlight: highlightSearchTerms(video.channel, query)
                    });
                }
            });
            
            if (matchingVideos.length === 0) {
                showVideoSearchNoResults();
                return;
            }
            
            // Display results
            const resultsList = document.getElementById('videoSearchResultsList');
            resultsList.innerHTML = matchingVideos.map(video => `
                <div class="video-search-result flex items-center gap-3 p-3 bg-gray-50 dark:bg-gray-700 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-600 cursor-pointer transition-colors"
                     onclick="playVideoFromSearchResult('${playlistName}', ${video.index})">
                    <img src="${video.thumbnail}" alt="${video.title}" class="w-16 h-12 object-cover rounded">
                    <div class="flex-1 min-w-0">
                        <div class="font-medium text-sm line-clamp-2 mb-1">${video.titleHighlight}</div>
                        <div class="text-xs text-gray-600 dark:text-gray-400 mb-1">${video.channelHighlight}</div>
                        <div class="text-xs text-gray-500 dark:text-gray-500">
                            ä½ç½®ï¼š${playlist.videos.length}ä¸­çš„ç¬¬${video.index + 1}å€‹
                            ${video.index === currentVideoIndex ? ' â€¢ æ­£åœ¨æ’­æ”¾' : ''}
                        </div>
                    </div>
                    <div class="flex flex-col gap-1">
                        <button 
                            onclick="playVideoFromSearchResult('${playlistName}', ${video.index}); event.stopPropagation();"
                            class="px-2 py-1 bg-primary text-white rounded hover:bg-opacity-90 transition-colors text-xs"
                            title="Play this video"
                        >
                            â–¶ï¸æ’­æ”¾
                        </button>
                        <button 
                            onclick="jumpToVideoInPlaylist('${playlistName}', ${video.index}); event.stopPropagation();"
                            class="px-2 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors text-xs"
                            title="Show in playlist"
                        >
                            ğŸ“é¡¯ç¤º
                        </button>
                    </div>
                </div>
            `).join('');
            
            showVideoSearchResults();
        }

        function highlightSearchTerms(text, searchQuery) {
            if (!searchQuery) return text;
            
            const queryLower = searchQuery.toLowerCase();
            const textLower = text.toLowerCase();
            
            if (!textLower.includes(queryLower)) return text;
            
            // Find the match position
            const matchIndex = textLower.indexOf(queryLower);
            const beforeMatch = text.substring(0, matchIndex);
            const match = text.substring(matchIndex, matchIndex + searchQuery.length);
            const afterMatch = text.substring(matchIndex + searchQuery.length);
            
            return `${beforeMatch}<mark class="bg-yellow-200 dark:bg-yellow-600 px-1 rounded">${match}</mark>${afterMatch}`;
        }

        function playVideoFromSearchResult(playlistName, videoIndex) {
            // Close the search dialog
            hideVideoSearchDialog();
            
            // Load the playlist if it's not currently loaded
            if (currentPlaylist !== playlistName) {
                loadPlaylist(playlistName);
            }
            
            // Play the video
            setTimeout(() => {
                playVideoFromPlaylist(videoIndex);
            }, 100);
        }

        function jumpToVideoInPlaylist(playlistName, videoIndex) {
            // Close the search dialog
            hideVideoSearchDialog();
            
            // Load the playlist if it's not currently loaded
            if (currentPlaylist !== playlistName) {
                loadPlaylist(playlistName);
            }
            
            // Scroll to the video in the playlist
            setTimeout(() => {
                const videoElement = document.querySelector(`[data-index="${videoIndex}"]`);
                if (videoElement) {
                    videoElement.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center' 
                    });
                    
                    // Add a temporary highlight effect
                    videoElement.style.backgroundColor = 'rgba(93, 92, 222, 0.3)';
                    setTimeout(() => {
                        videoElement.style.backgroundColor = '';
                    }, 2000);
                }
            }, 100);
        }

        // URL Parameter Auto-Play Functions
        function checkForAutoPlayURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const urlParam = urlParams.get('url');
            
            if (urlParam) {
                console.log('URL parameter detected:', urlParam);
                handleAutoPlayURL(urlParam);
            }
        }

        function handleAutoPlayURL(url) {
            try {
                // Determine URL type and extract appropriate ID
                const urlInfo = parseYouTubeURL(url);
                
                if (urlInfo.type === 'video' && urlInfo.id) {
                    console.log('Extracted video ID:', urlInfo.id);
                    handleAutoPlayVideo(urlInfo.id);
                } else if (urlInfo.type === 'channel' && urlInfo.id) {
                    console.log('Extracted channel ID:', urlInfo.id);
                    handleAutoPlayChannel(urlInfo.id, urlInfo.name);
                } else if (urlInfo.type === 'playlist' && urlInfo.id) {
                    console.log('Extracted playlist ID:', urlInfo.id);
                    handleAutoPlayPlaylist(urlInfo.id);
                } else {
                    console.error('Could not extract valid ID from URL:', url);
                    showAutoPlayError('Invalid or unsupported YouTube URL provided');
                }
            } catch (error) {
                console.error('Error processing auto-play URL:', error);
                showAutoPlayError('Error processing the provided URL');
            }
        }

        function parseYouTubeURL(url) {
            // Video patterns
            const videoPatterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/)([a-zA-Z0-9_-]{11})/,
                /youtube\.com\/watch\?.*v=([a-zA-Z0-9_-]{11})/,
                /youtu\.be\/([a-zA-Z0-9_-]{11})/,
                /m\.youtube\.com\/watch\?.*v=([a-zA-Z0-9_-]{11})/,
                /gaming\.youtube\.com\/watch\?.*v=([a-zA-Z0-9_-]{11})/
            ];
            
            // Channel patterns
            const channelPatterns = [
                /youtube\.com\/channel\/([a-zA-Z0-9_-]+)/,
                /youtube\.com\/c\/([a-zA-Z0-9_-]+)/,
                /youtube\.com\/user\/([a-zA-Z0-9_-]+)/,
                /youtube\.com\/@([a-zA-Z0-9_-]+)/,
                /m\.youtube\.com\/channel\/([a-zA-Z0-9_-]+)/,
                /m\.youtube\.com\/c\/([a-zA-Z0-9_-]+)/,
                /m\.youtube\.com\/user\/([a-zA-Z0-9_-]+)/
            ];
            
            // Playlist patterns
            const playlistPatterns = [
                /youtube\.com\/playlist\?list=([a-zA-Z0-9_-]+)/,
                /youtube\.com\/watch\?.*list=([a-zA-Z0-9_-]+)/,
                /m\.youtube\.com\/playlist\?list=([a-zA-Z0-9_-]+)/,
                /m\.youtube\.com\/watch\?.*list=([a-zA-Z0-9_-]+)/
            ];
            
            // Check for video URLs first
            for (const pattern of videoPatterns) {
                const match = url.match(pattern);
                if (match && match[1]) {
                    return { type: 'video', id: match[1] };
                }
            }
            
            // Check for playlist URLs
            for (const pattern of playlistPatterns) {
                const match = url.match(pattern);
                if (match && match[1]) {
                    return { type: 'playlist', id: match[1] };
                }
            }
            
            // Check for channel URLs
            for (const pattern of channelPatterns) {
                const match = url.match(pattern);
                if (match && match[1]) {
                    let channelId = match[1];
                    let channelType = 'id';
                    
                    // Determine channel type based on URL pattern
                    if (url.includes('/c/')) {
                        channelType = 'username';
                    } else if (url.includes('/user/')) {
                        channelType = 'username';
                    } else if (url.includes('/@')) {
                        channelType = 'handle';
                        channelId = channelId.replace('@', '');
                    }
                    
                    return { 
                        type: 'channel', 
                        id: channelId, 
                        channelType: channelType,
                        name: channelId 
                    };
                }
            }
            
            return { type: 'unknown', id: null };
        }

        function handleAutoPlayVideo(videoId) {
            // Wait for YouTube API to be ready before playing
            const attemptPlay = () => {
                if (playerReady && window.YT) {
                    // Fetch video details first to get title and channel
                    fetchVideoDetailsForAutoPlay(videoId);
                } else {
                    // Retry after a short delay
                    setTimeout(attemptPlay, 500);
                }
            };
            
            attemptPlay();
        }

        async function handleAutoPlayChannel(channelIdentifier, channelName) {
            if (!apiKey) {
                showAutoPlayError('API key required to load channel content');
                return;
            }
            
            try {
                showAutoPlayLoading(`Loading channel: ${channelName}...`);
                
                // First, resolve the channel ID if we have a username or handle
                let channelId = channelIdentifier;
                let resolvedChannelTitle = channelName;
                
                if (!channelIdentifier.startsWith('UC')) {
                    // Need to resolve username/handle to channel ID
                    const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(channelIdentifier)}&type=channel&maxResults=1&key=${apiKey}`;
                    const searchResponse = await fetch(searchUrl);
                    
                    if (searchResponse.ok) {
                        const searchData = await searchResponse.json();
                        if (searchData.items && searchData.items.length > 0) {
                            channelId = searchData.items[0].id.channelId;
                            resolvedChannelTitle = searchData.items[0].snippet.title;
                        } else {
                            throw new Error('Channel not found');
                        }
                    } else {
                        throw new Error('Failed to resolve channel');
                    }
                }
                
                // Update search type and navigate to channel videos
                setSearchType('video');
                await viewChannelVideos(channelId, resolvedChannelTitle);
                hideAutoPlayLoading();
                showAutoPlaySuccess(`Loaded channel: ${resolvedChannelTitle}`);
                
            } catch (error) {
                console.error('Error loading channel:', error);
                hideAutoPlayLoading();
                showAutoPlayError(`Failed to load channel: ${error.message}`);
            }
        }

        async function handleAutoPlayPlaylist(playlistId) {
            if (!apiKey) {
                showAutoPlayError('API key required to load playlist content');
                return;
            }
            
            try {
                showAutoPlayLoading('Loading playlist...');
                
                // Get playlist info first
                const playlistInfoUrl = `https://www.googleapis.com/youtube/v3/playlists?part=snippet&id=${playlistId}&key=${apiKey}`;
                const playlistResponse = await fetch(playlistInfoUrl);
                
                if (!playlistResponse.ok) {
                    throw new Error(`Playlist API Error (${playlistResponse.status})`);
                }
                
                const playlistData = await playlistResponse.json();
                
                if (!playlistData.items || playlistData.items.length === 0) {
                    throw new Error('Playlist not found or is private');
                }
                
                const playlistInfo = playlistData.items[0];
                const playlistTitle = playlistInfo.snippet.title;
                const channelTitle = playlistInfo.snippet.channelTitle;
                
                updateAutoPlayLoading(`Loading videos from: ${playlistTitle}...`);
                
                // Show playlist import dialog
                showPlaylistImportDialog(playlistId, playlistTitle, channelTitle);
                hideAutoPlayLoading();
                
            } catch (error) {
                console.error('Error loading playlist:', error);
                hideAutoPlayLoading();
                showAutoPlayError(`Failed to load playlist: ${error.message}`);
            }
        }

        function showPlaylistImportDialog(playlistId, playlistTitle, channelTitle) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'autoPlaylistOverlay';
            
            const modal = document.createElement('div');
            modal.className = 'rename-form';
            modal.style.minWidth = '400px';
            modal.style.maxWidth = '500px';
            
            modal.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">ğŸ“‹ YouTube Playlist Detected</h3>
                
                <div class="mb-4 p-3 bg-blue-50 dark:bg-blue-900 rounded-lg">
                    <div class="font-medium text-blue-900 dark:text-blue-100">${playlistTitle}</div>
                    <div class="text-sm text-blue-700 dark:text-blue-300">by ${channelTitle}</div>
                </div>
                
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                    What would you like to do with this playlist?
                </p>
                
                <div class="space-y-3 mb-6">
                    <button 
                        onclick="importAndLoadPlaylist('${playlistId}', '${escapeHtml(playlistTitle)}')" 
                        class="w-full px-4 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-left flex items-center gap-3"
                    >
                        <span class="text-xl">ğŸ“¥</span>
                        <div>
                            <div class="font-medium">Import Playlist</div>
                            <div class="text-sm opacity-90">Import all videos and start playing</div>
                        </div>
                    </button>
                    
                    <button 
                        onclick="viewPlaylistVideosFromURL('${playlistId}', '${escapeHtml(playlistTitle)}')" 
                        class="w-full px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors text-left flex items-center gap-3"
                    >
                        <span class="text-xl">ğŸ‘€</span>
                        <div>
                            <div class="font-medium">Browse Videos</div>
                            <div class="text-sm opacity-90">View videos without importing</div>
                        </div>
                    </button>
                </div>
                
                <div class="flex gap-3 justify-end">
                    <button 
                        onclick="hideAutoPlaylistDialog()" 
                        class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
                    >
                        å–æ¶ˆ
                    </button>
                </div>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hideAutoPlaylistDialog();
                }
            });
        }

        function hideAutoPlaylistDialog() {
            const overlay = document.getElementById('autoPlaylistOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        async function importAndLoadPlaylist(playlistId, playlistTitle) {
            hideAutoPlaylistDialog();
            
            try {
                // Import the playlist
                await importYouTubePlaylist(playlistId, playlistTitle);
                
                // Load the imported playlist
                setTimeout(() => {
                    loadPlaylist(playlistTitle);
                    
                    // Auto-play first video if available
                    if (playlists[playlistTitle] && playlists[playlistTitle].videos.length > 0) {
                        setTimeout(() => {
                            playVideoFromPlaylist(0);
                        }, 1000);
                    }
                }, 1000);
                
            } catch (error) {
                console.error('Error importing playlist:', error);
                showAutoPlayError('Failed to import playlist');
            }
        }

        async function viewPlaylistVideosFromURL(playlistId, playlistTitle) {
            hideAutoPlaylistDialog();
            
            try {
                // View playlist videos directly
                await viewPlaylistVideos(playlistId, playlistTitle);
                showAutoPlaySuccess(`Viewing playlist: ${playlistTitle}`);
                
            } catch (error) {
                console.error('Error viewing playlist videos:', error);
                showAutoPlayError('Failed to load playlist videos');
            }
        }

        // Legacy function for backward compatibility
        function extractYouTubeVideoId(url) {
            const urlInfo = parseYouTubeURL(url);
            return urlInfo.type === 'video' ? urlInfo.id : null;
        }

        async function fetchVideoDetailsForAutoPlay(videoId) {
            if (!apiKey) {
                // Play without details if no API key
                playVideo(videoId, 'Loading...', 'YouTube');
                showAutoPlaySuccess('Video loaded from URL');
                return;
            }

            try {
                const videoUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoId}&key=${apiKey}`;
                const response = await fetch(videoUrl);
                
                if (!response.ok) {
                    throw new Error(`API Error (${response.status})`);
                }
                
                const data = await response.json();
                
                if (data.items && data.items.length > 0) {
                    const video = data.items[0];
                    const title = video.snippet.title;
                    const channel = video.snippet.channelTitle;
                    
                    // Play the video with proper details
                    playVideo(videoId, title, channel);
                    showAutoPlaySuccess(`Now playing: ${title}`);
                } else {
                    // Video not found, but try to play anyway
                    playVideo(videoId, 'Video from URL', 'YouTube');
                    showAutoPlaySuccess('Video loaded from URL');
                }
                
            } catch (error) {
                console.error('Error fetching video details for auto-play:', error);
                // Play without details if API fails
                playVideo(videoId, 'Video from URL', 'YouTube');
                showAutoPlaySuccess('Video loaded from URL');
            }
        }

        function showAutoPlaySuccess(message) {
            const feedback = document.createElement('div');
            feedback.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 bg-green-600 text-white px-6 py-3 rounded-lg shadow-lg z-50 transition-opacity flex items-center gap-2';
            feedback.innerHTML = `
                <span>ğŸ¬</span>
                <span>${message}</span>
            `;
            document.body.appendChild(feedback);
            
            // Auto-remove feedback after 4 seconds
            setTimeout(() => {
                feedback.style.opacity = '0';
                setTimeout(() => feedback.remove(), 300);
            }, 4000);
        }

        function showAutoPlayError(message) {
            const feedback = document.createElement('div');
            feedback.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 bg-red-600 text-white px-6 py-3 rounded-lg shadow-lg z-50 transition-opacity flex items-center gap-2';
            feedback.innerHTML = `
                <span>âŒ</span>
                <span>${message}</span>
            `;
            document.body.appendChild(feedback);
            
            // Auto-remove feedback after 6 seconds (longer for errors)
            setTimeout(() => {
                feedback.style.opacity = '0';
                setTimeout(() => feedback.remove(), 300);
            }, 6000);
        }

        // Auto-play loading state functions
        function showAutoPlayLoading(message) {
            const loading = document.createElement('div');
            loading.id = 'autoPlayLoading';
            loading.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 bg-blue-600 text-white px-6 py-3 rounded-lg shadow-lg z-50 flex items-center gap-3';
            loading.innerHTML = `
                <div class="animate-spin inline-block w-5 h-5 border-2 border-current border-t-transparent rounded-full"></div>
                <span id="autoPlayLoadingText">${message}</span>
            `;
            document.body.appendChild(loading);
        }

        function updateAutoPlayLoading(message) {
            const loadingText = document.getElementById('autoPlayLoadingText');
            if (loadingText) {
                loadingText.textContent = message;
            }
        }

        function hideAutoPlayLoading() {
            const loading = document.getElementById('autoPlayLoading');
            if (loading) {
                loading.remove();
            }
        }

        // Add Current Video to Playlist Function
        function addCurrentVideoToPlaylist() {
            if (!player) {
                alert('No video is currently playing');
                return;
            }
            
            try {
                // Get current video data
                const videoData = player.getVideoData();
                if (!videoData || !videoData.video_id) {
                    alert('Unable to get current video information');
                    return;
                }
                
                const videoId = videoData.video_id;
                const title = videoData.title || document.getElementById('videoTitle').textContent.replace('Now Playing:', '').trim();
                const channel = document.getElementById('videoChannel').textContent;
                const thumbnail = `https://img.youtube.com/vi/${videoId}/default.jpg`;
                
                // Show add to playlist menu
                showAddToPlaylistMenuForCurrentVideo(videoId, title, channel, thumbnail);
                
            } catch (error) {
                console.error('Error getting current video data:', error);
                alert('Unable to get current video information');
            }
        }

        function showAddToPlaylistMenuForCurrentVideo(videoId, title, channel, thumbnail) {
            const playlistNames = Object.keys(playlists);
            
            if (playlistNames.length === 0) {
                alert('Create a playlist first!');
                return;
            }
            
            // Remove any existing dropdown
            const existingDropdown = document.querySelector('.current-video-playlist-dropdown');
            if (existingDropdown) {
                existingDropdown.remove();
            }
            
            // Create dropdown menu
            const dropdown = document.createElement('div');
            dropdown.className = 'current-video-playlist-dropdown fixed bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg shadow-xl py-2 min-w-48 max-h-64 overflow-y-auto';
            dropdown.style.zIndex = '9999';
            
            // Add header
            const header = document.createElement('div');
            header.className = 'px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 border-b border-gray-200 dark:border-gray-600';
            header.textContent = 'Add current video to:';
            dropdown.appendChild(header);
            
            // Add playlist options
            playlistNames.forEach(playlistName => {
                const option = document.createElement('div');
                option.className = 'px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-600 cursor-pointer transition-colors';
                option.textContent = `${playlistName} (${playlists[playlistName].videos.length} videos)`;
                option.onclick = () => {
                    addToPlaylist(playlistName, { id: videoId, title, channel, thumbnail });
                    dropdown.remove();
                    
                    // Show success message
                    showSuccessMessage(`âœ…å·²æ·»åŠ ã€Œ${title}"ã€è‡³ã€Œ${playlistName}ã€`);
                };
                dropdown.appendChild(option);
            });
            
            // Position dropdown in center of screen
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;
            
            const dropdownHeight = Math.min(playlistNames.length * 40 + 60, 256);
            const dropdownWidth = 192;
            
            const top = (viewportHeight - dropdownHeight) / 2;
            const left = (viewportWidth - dropdownWidth) / 2;
            
            dropdown.style.top = Math.max(20, top) + 'px';
            dropdown.style.left = Math.max(20, left) + 'px';
            
            // Append to body
            document.body.appendChild(dropdown);
            
            // Close dropdown when clicking outside
            const closeDropdown = (e) => {
                if (!dropdown.contains(e.target)) {
                    dropdown.remove();
                    document.removeEventListener('click', closeDropdown);
                }
            };
            
            // Add event listener after a small delay to prevent immediate closure
            setTimeout(() => {
                document.addEventListener('click', closeDropdown);
            }, 100);
        }

        // Share Current Video Function
        function shareCurrentVideo() {
            if (!player) {
                alert('No video is currently playing');
                return;
            }
            
            try {
                // Get current video data
                const videoData = player.getVideoData();
                if (!videoData || !videoData.video_id) {
                    alert('Unable to get current video information');
                    return;
                }
                
                const videoId = videoData.video_id;
                const shareUrl = `https://tsetse6789.github.io/player?url=https://youtu.be/${videoId}`;
                
                // Copy to clipboard
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(shareUrl).then(() => {
                        showShareSuccessMessage('âœ…åˆ†äº«URLå·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼', shareUrl);
                    }).catch(error => {
                        console.error('Failed to copy to clipboard:', error);
                        showShareFallback(shareUrl);
                    });
                } else {
                    // Fallback for browsers that don't support clipboard API
                    showShareFallback(shareUrl);
                }
                
            } catch (error) {
                console.error('Error getting current video data for sharing:', error);
                alert('Unable to get current video information');
            }
        }

        function showShareSuccessMessage(message, url) {
            const feedback = document.createElement('div');
            feedback.className = 'fixed top-4 right-4 bg-blue-600 text-white px-4 py-3 rounded-lg shadow-lg z-50 transition-opacity max-w-sm';
            feedback.innerHTML = `
                <div class="font-medium mb-1">${message}</div>
                <div class="text-xs opacity-90 break-all">${url}</div>
            `;
            document.body.appendChild(feedback);
            
            // Auto-remove feedback after 4 seconds
            setTimeout(() => {
                feedback.style.opacity = '0';
                setTimeout(() => feedback.remove(), 300);
            }, 4000);
        }

        function showShareFallback(url) {
            // Create a modal with the URL for manual copying
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'shareUrlOverlay';
            
            const modal = document.createElement('div');
            modal.className = 'rename-form';
            modal.style.minWidth = '400px';
            modal.style.maxWidth = '500px';
            
            modal.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">ğŸ“¤åˆ†äº«å½±ç‰‡</h3>
                
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-3">
                    è¤‡è£½æ­¤URLä»¥åˆ†äº«ç•¶å‰å½±ç‰‡ï¼š
                </p>
                
                <div class="mb-4">
                    <textarea 
                        id="shareUrlText" 
                        readonly
                        class="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded bg-gray-50 dark:bg-gray-800 text-gray-900 dark:text-white resize-none"
                        rows="3"
                    >${url}</textarea>
                </div>
                
                <div class="flex gap-3 justify-end">
                    <button 
                        onclick="hideShareUrlModal()" 
                        class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
                    >
                        é—œé–‰
                    </button>
                    <button 
                        onclick="selectShareUrl()" 
                        class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
                    >
                        ğŸ“‹å…¨é¸
                    </button>
                </div>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // Focus and select the text
            const textarea = document.getElementById('shareUrlText');
            textarea.focus();
            textarea.select();
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hideShareUrlModal();
                }
            });
        }

        function selectShareUrl() {
            const textarea = document.getElementById('shareUrlText');
            textarea.focus();
            textarea.select();
            
            // Try to copy again
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(textarea.value).then(() => {
                    hideShareUrlModal();
                    showShareSuccessMessage('âœ…åˆ†äº«URLå·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼', textarea.value);
                }).catch(error => {
                    console.error('Failed to copy to clipboard:', error);
                });
            }
        }

        function hideShareUrlModal() {
            const overlay = document.getElementById('shareUrlOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        // Process Description Links Function
        function processDescriptionLinks(description) {
            if (!description) return description;
            
            // Escape HTML first to prevent XSS
            const escapeHtml = (text) => {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            };
            
            let processedText = escapeHtml(description);
            
            // Process @ mentions (channel mentions)
            processedText = processedText.replace(
                /@([a-zA-Z0-9_.-]+)/g,
                '<span class="mention-link cursor-pointer text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 underline" onclick="searchChannelFromMention(\'$1\')">@$1</span>'
            );
            
            // Process # hashtags
            processedText = processedText.replace(
                /#([a-zA-Z0-9_]+)/g,
                '<span class="hashtag-link cursor-pointer text-purple-600 dark:text-purple-400 hover:text-purple-800 dark:hover:text-purple-200 underline" onclick="searchHashtagFromDescription(\'$1\')">#$1</span>'
            );
            
            // Convert line breaks to HTML line breaks
            processedText = processedText.replace(/\n/g, '<br>');
            
            return processedText;
        }

        // Search Channel from @ Mention
        function searchChannelFromMention(channelName) {
            // Set search type to channel
            setSearchType('channel');
            
            // Set search input
            const searchInput = document.getElementById('searchInput');
            searchInput.value = channelName;
            
            // Perform the search
            searchChannels();
            
            // Show feedback
            showSuccessMessage(`ğŸ” æ­£åœ¨æœå°‹é »é“ï¼š@${channelName}`);
        }

        // Search Videos with Hashtag
        function searchHashtagFromDescription(hashtag) {
            // Set search type to video
            setSearchType('video');
            
            // Set search input with hashtag
            const searchInput = document.getElementById('searchInput');
            searchInput.value = `#${hashtag}`;
            
            // Perform the search
            searchVideos();
            
            // Show feedback
            showSuccessMessage(`ğŸ” æ­£åœ¨ç”¨æ¨™ç±¤æœå°‹å½±ç‰‡ï¼š#${hashtag}`);
        }

        // ========================================
        // QUEUE SYSTEM FUNCTIONS
        // ========================================

        // Queue Management Functions
        function addToQueue(video, position = 'end') {
            if (!video || !video.id) return;
            
            // Check if video already exists in queue
            const existingIndex = playQueue.findIndex(queueVideo => queueVideo.id === video.id);
            if (existingIndex !== -1) {
                showSuccessMessage(`ğŸµå½±ç‰‡å·²ç¶“åœ¨æ’­æ”¾åˆ—è¡¨çš„ç¬¬${existingIndex + 1}éƒ¨`);
                return;
            }
            
            // Add video to specified position
            switch (position) {
                case 'next':
                    playQueue.splice(currentQueueIndex + 1, 0, video);
                    break;
                case 'current':
                    // Stop current playback and insert at current position
                    playQueue.splice(currentQueueIndex, 0, video);
                    playFromQueue(currentQueueIndex);
                    break;
                default: // 'end'
                    playQueue.push(video);
                    break;
            }
            
            updateQueueUI();
            
            // Show success message
            const positionText = position === 'next' ? 'next' : position === 'current' ? 'now' : 'end of queue';
            showSuccessMessage(`ğŸµ Added "${video.title}" to ${positionText}`);
        }

        function addPlaylistToQueue(playlistName, startIndex = 0) {
            if (!playlists[playlistName]) return;
            
            const videos = playlists[playlistName].videos;
            if (videos.length === 0) return;
            
            // Apply shuffle if enabled
            let videosToAdd = [...videos];
            if (playbackSettings.shuffle) {
                videosToAdd = shuffleArray(videosToAdd);
                // Ensure the selected video comes first
                if (startIndex !== 0 && startIndex < videos.length) {
                    const selectedVideo = videos[startIndex];
                    videosToAdd = videosToAdd.filter(v => v.id !== selectedVideo.id);
                    videosToAdd.unshift(selectedVideo);
                }
            } else if (startIndex !== 0) {
                // Reorder to start from selected video
                videosToAdd = videos.slice(startIndex).concat(videos.slice(0, startIndex));
            }
            
            // Clear queue and add new videos
            playQueue = [...videosToAdd];
            currentQueueIndex = 0;
            
            updateQueueUI();
            showSuccessMessage(`ğŸµå·²æ·»åŠ ã€Œ${playlistName}ã€è‡³æ’­æ”¾åˆ—è¡¨ï¼ˆ${videos.length}éƒ¨å½±ç‰‡ï¼‰`);
        }

        function removeFromQueue(index) {
            if (index < 0 || index >= playQueue.length) return;
            
            const removedVideo = playQueue[index];
            playQueue.splice(index, 1);
            
            // Adjust current index if needed
            if (index < currentQueueIndex) {
                currentQueueIndex--;
            } else if (index === currentQueueIndex && index >= playQueue.length) {
                currentQueueIndex = Math.max(0, playQueue.length - 1);
            }
            
            updateQueueUI();
            
            // If we removed the currently playing video, play next or stop
            if (index === currentQueueIndex && player) {
                if (playQueue.length > 0) {
                    playFromQueue(currentQueueIndex);
                } else {
                    clearVideo();
                }
            }
            
            showSuccessMessage(`ğŸ—‘ï¸æˆåŠŸå¾æ’­æ”¾åˆ—è¡¨ç§»é™¤ã€Œ${removedVideo.title}ã€`);
        }

        function clearQueue() {
            playQueue = [];
            currentQueueIndex = 0;
            updateQueueUI();
            clearVideo();
            showSuccessMessage('ğŸ§¹ Queue cleared');
        }

        function playFromQueue(index) {
            if (index < 0 || index >= playQueue.length) return;
            
            currentQueueIndex = index;
            const video = playQueue[index];
            
            // Play the video using existing function
            playVideo(video.id, video.title, video.channel);
            
            updateQueueUI();
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Queue UI Functions
        function updateQueueUI() {
            updateQueueFAB();
            updateQueuePanel();
        }

        function updateQueueFAB() {
            const fab = document.getElementById('queueFab');
            const count = document.getElementById('queueCount');
            
            if (playQueue.length > 0) {
                fab.classList.add('has-queue');
                count.textContent = playQueue.length;
                count.classList.remove('hidden');
                fab.title = `Queue (${playQueue.length} videos)`;
            } else {
                fab.classList.remove('has-queue');
                count.classList.add('hidden');
                fab.title = 'Queue';
            }
        }

        function updateQueuePanel() {
            const statusText = document.getElementById('queueStatusText');
            const emptyState = document.getElementById('queueEmpty');
            const queueList = document.getElementById('queueList');
            
            if (playQueue.length === 0) {
                statusText.textContent = 'æ²’æœ‰å½±ç‰‡';
                emptyState.classList.remove('hidden');
                queueList.classList.add('hidden');
                queueList.innerHTML = '';
                return;
            }
            
            const nowPlaying = playQueue[currentQueueIndex];
            const nextVideo = playQueue[currentQueueIndex + 1];
            
            let statusMsg = `${playQueue.length}éƒ¨å½±ç‰‡`;
            if (nowPlaying) {
                const nowPlayingText = nowPlaying.title.length > 15 ? nowPlaying.title.substring(0, 15) + '...' : nowPlaying.title;
                statusMsg += ` â€¢ ç¾åœ¨æ’­æ”¾ï¼š${nowPlayingText}`;
                
                if (nextVideo) {
                    const nextText = nextVideo.title.length > 15 ? nextVideo.title.substring(0, 15) + '...' : nextVideo.title;
                    statusMsg += ` â€¢ ä¸‹ä¸€å€‹ï¼š${nextText}`;
                }
            }
            
            statusText.textContent = statusMsg;
            emptyState.classList.add('hidden');
            queueList.classList.remove('hidden');
            
            // Render queue items
            queueList.innerHTML = playQueue.map((video, index) => `
                <div class="queue-item ${index === currentQueueIndex ? 'active' : ''} ${isQueueSelectionMode ? 'selection-mode' : ''}" 
                     data-queue-index="${index}"
                     draggable="${!isQueueSelectionMode}"
                     onclick="${isQueueSelectionMode ? `toggleQueueVideoSelection(${index}, event)` : ''}"
                     ondragstart="handleQueueDragStart(event, ${index})"
                     ondragover="handleQueueDragOver(event)"
                     ondrop="handleQueueDrop(event, ${index})"
                     ondragend="handleQueueDragEnd(event)">
                    ${isQueueSelectionMode ? `
                        <input type="checkbox" class="queue-checkbox" data-queue-index="${index}" onchange="updateQueueSelectedCount()" onclick="event.stopPropagation()">
                    ` : ''}
                    <img src="${video.thumbnail}" alt="${video.title}" class="queue-thumbnail">
                    <div class="queue-info">
                        <div class="queue-title">${video.title}</div>
                        <div class="queue-channel">${video.channel}</div>
                    </div>
                    <div class="queue-actions">
                        ${!isQueueSelectionMode ? `
                            ${index !== currentQueueIndex ? `
                                <button class="queue-btn play" onclick="playFromQueue(${index})" title="Play now">
                                    â–¶ï¸
                                </button>
                            ` : `
                                <div class="queue-btn" style="background: rgba(16, 185, 129, 0.3); color: #10b981;" title="Currently playing">
                                    ğŸµ
                                </div>
                            `}
                            <button class="queue-btn remove" onclick="removeFromQueue(${index})" title="Remove from queue">
                                âœ•
                            </button>
                        ` : ''}
                    </div>
                </div>
            `).join('');
        }

        function toggleQueuePanel() {
            const panel = document.getElementById('queuePanel');
            
            if (isQueuePanelOpen) {
                closeQueuePanel();
            } else {
                openQueuePanel();
            }
        }

        function openQueuePanel() {
            const panel = document.getElementById('queuePanel');
            panel.classList.add('open');
            isQueuePanelOpen = true;
            updateQueuePanel(); // Refresh content when opening
        }

        function closeQueuePanel() {
            const panel = document.getElementById('queuePanel');
            panel.classList.remove('open');
            isQueuePanelOpen = false;
        }

        // Queue Drag and Drop
        let queueDragData = {
            draggedIndex: null,
            draggedElement: null
        };

        function handleQueueDragStart(event, index) {
            queueDragData.draggedIndex = index;
            queueDragData.draggedElement = event.target;
            
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/html', event.target.outerHTML);
        }

        function handleQueueDragOver(event) {
            if (queueDragData.draggedIndex === null) return;
            
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            
            const rect = event.currentTarget.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            
            if (event.clientY < midpoint) {
                event.currentTarget.classList.add('drag-over');
            } else {
                event.currentTarget.classList.remove('drag-over');
            }
        }

        function handleQueueDrop(event, dropIndex) {
            if (queueDragData.draggedIndex === null) return;
            
            event.preventDefault();
            
            const draggedIndex = queueDragData.draggedIndex;
            if (draggedIndex === dropIndex) return;
            
            // Reorder queue
            const draggedVideo = playQueue[draggedIndex];
            playQueue.splice(draggedIndex, 1);
            
            // Adjust drop index if needed
            if (draggedIndex < dropIndex) {
                dropIndex--;
            }
            
            playQueue.splice(dropIndex, 0, draggedVideo);
            
            // Update current index if needed
            if (currentQueueIndex === draggedIndex) {
                currentQueueIndex = dropIndex;
            } else if (currentQueueIndex > draggedIndex && currentQueueIndex <= dropIndex) {
                currentQueueIndex--;
            } else if (currentQueueIndex < draggedIndex && currentQueueIndex >= dropIndex) {
                currentQueueIndex++;
            }
            
            updateQueueUI();
        }

        function handleQueueDragEnd(event) {
            if (queueDragData.draggedElement) {
                queueDragData.draggedElement.classList.remove('dragging');
            }
            
            // Remove all drag-over classes
            document.querySelectorAll('.queue-item').forEach(el => {
                el.classList.remove('drag-over');
            });
            
            queueDragData.draggedIndex = null;
            queueDragData.draggedElement = null;
        }

        // Play Options Dialog
        function showPlayOptionsDialog(video, sourceType = 'search') {
            // Check if queue is empty - if so, just add and play immediately
            if (playQueue.length === 0) {
                addToQueue(video, 'current');
                return;
            }
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'playOptionsOverlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'play-options-dialog';
            
            dialog.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">ğŸµæ·»åŠ è‡³æ’­æ”¾åˆ—è¡¨</h3>
                
                <div class="mb-4 p-3 bg-gray-50 dark:bg-gray-700 rounded-lg">
                    <div class="font-medium text-sm line-clamp-2 mb-1">${video.title}</div>
                    <div class="text-xs text-gray-600 dark:text-gray-400">${video.channel}</div>
                </div>
                
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                    æ’­æ”¾åˆ—è¡¨å·²ç¶“æœ‰${playQueue.length}éƒ¨å½±ç‰‡ï¼Œæ‚¨æƒ³æŠŠå½±ç‰‡æ·»åŠ è‡³å“ªè£ï¼Ÿ
                </p>
                
                <div class="space-y-2 mb-6">
                    <button onclick="addToQueue(${JSON.stringify(video).replace(/"/g, '&quot;')}, 'current'); hidePlayOptionsDialog()" class="play-option-btn">
                        <div class="play-option-icon">â–¶ï¸</div>
                        <div class="play-option-content">
                            <div class="play-option-title">ç¾åœ¨æ’­æ”¾</div>
                            <div class="play-option-desc">åœæ­¢ç•¶å‰å½±ç‰‡ä¸¦ç«‹å³æ’­æ”¾</div>
                        </div>
                    </button>
                    
                    <button onclick="addToQueue(${JSON.stringify(video).replace(/"/g, '&quot;')}, 'next'); hidePlayOptionsDialog()" class="play-option-btn">
                        <div class="play-option-icon">â­ï¸</div>
                        <div class="play-option-content">
                            <div class="play-option-title">æ¥ä¸‹ä¾†æ’­æ”¾</div>
                            <div class="play-option-desc">åœ¨ç•¶å‰å½±ç‰‡ä¹‹å¾Œæ–°å¢ï¼ˆåˆ—è¡¨ä¸­çš„ä¸‹ä¸€å€‹ï¼‰</div>
                        </div>
                    </button>
                    
                    <button onclick="addToQueue(${JSON.stringify(video).replace(/"/g, '&quot;')}, 'end'); hidePlayOptionsDialog()" class="play-option-btn">
                        <div class="play-option-icon">ğŸ“</div>
                        <div class="play-option-content">
                            <div class="play-option-title">æ–°å¢åˆ°çµå°¾</div>
                            <div class="play-option-desc">æ–°å¢åˆ°æ’­æ”¾åˆ—è¡¨çš„æœ«å°¾</div>
                        </div>
                    </button>
                </div>
                
                <div class="flex gap-3 justify-end">
                    <button onclick="hidePlayOptionsDialog()" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors">
                        å–æ¶ˆ
                    </button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hidePlayOptionsDialog();
                }
            });
        }

        function hidePlayOptionsDialog() {
            const overlay = document.getElementById('playOptionsOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        // Modified video end handler for queue system
        function handleVideoEndWithQueue() {
            // Remove current video if not in repeat mode
            if (playbackSettings.repeat === 'é—œé–‰') {
                if (playQueue.length > currentQueueIndex) {
                    playQueue.splice(currentQueueIndex, 1);
                    // Don't increment currentQueueIndex as we removed current item
                }
            } else if (playbackSettings.repeat === 'å–®æ›²') {
                // Replay same video
                playFromQueue(currentQueueIndex);
                return;
            } else if (playbackSettings.repeat === 'æ‰€æœ‰') {
                // Move to next video, loop to start if at end
                currentQueueIndex++;
                if (currentQueueIndex >= playQueue.length) {
                    currentQueueIndex = 0;
                }
            }
            
            // Play next video if available
            if (playQueue.length > currentQueueIndex) {
                playFromQueue(currentQueueIndex);
            } else {
                // Queue is empty
                clearVideo();
                updateQueueUI();
            }
        }

        // ========================================
        // NEW QUEUE FEATURES
        // ========================================

        // Queue Selection Mode Variables
        let isQueueSelectionMode = false;
        let selectedQueueVideos = new Set();

        // Queue Selection Mode Functions
        function toggleQueueSelectionMode() {
            isQueueSelectionMode = !isQueueSelectionMode;
            selectedQueueVideos.clear();
            
            const button = document.getElementById('queueSelectButton');
            const controls = document.getElementById('queueSelectionControls');
            
            if (isQueueSelectionMode) {
                button.textContent = 'å®Œæˆ';
                button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                button.classList.add('bg-red-600', 'hover:bg-red-700');
                controls.classList.remove('hidden');
            } else {
                button.textContent = 'é¸æ“‡';
                button.classList.remove('bg-red-600', 'hover:bg-red-700');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700');
                controls.classList.add('hidden');
            }
            
            updateQueuePanel();
            updateQueueSelectedCount();
        }

        function toggleQueueVideoSelection(index, event) {
            if (!isQueueSelectionMode) return;
            
            // Prevent event bubbling if this was called from a click event
            if (event) {
                event.stopPropagation();
            }
            
            const checkbox = document.querySelector(`input[data-queue-index="${index}"]`);
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                
                // Trigger change event to ensure all handlers are called
                const changeEvent = new Event('change', { bubbles: true });
                checkbox.dispatchEvent(changeEvent);
                
                updateQueueSelectedCount();
            }
        }
        function updateQueueSelectedCount() {
            if (!isQueueSelectionMode) return;
            
            const checkboxes = document.querySelectorAll('.queue-checkbox:checked');
            selectedQueueVideos = new Set(Array.from(checkboxes).map(cb => parseInt(cb.dataset.queueIndex)));
            
            const countElement = document.getElementById('queueSelectedCount');
            if (countElement) {
                countElement.textContent = selectedQueueVideos.size;
            }
        }

        function selectAllQueueVideos() {
            const checkboxes = document.querySelectorAll('.queue-checkbox');
            checkboxes.forEach(cb => cb.checked = true);
            updateQueueSelectedCount();
        }

        function deselectAllQueueVideos() {
            const checkboxes = document.querySelectorAll('.queue-checkbox');
            checkboxes.forEach(cb => cb.checked = false);
            updateQueueSelectedCount();
        }

        function deleteSelectedFromQueue() {
            if (selectedQueueVideos.size === 0) {
                showCustomAlert('Please select videos to delete', 'warning');
                return;
            }
            
            showCustomConfirm(
                `Delete ${selectedQueueVideos.size} selected videos from queue?`,
                () => {
                    const selectedIndices = Array.from(selectedQueueVideos).sort((a, b) => b - a); // Sort descending
                    let removedCount = 0;
                    
                    // Remove selected videos (in reverse order to maintain indices)
                    selectedIndices.forEach(index => {
                        if (index >= 0 && index < playQueue.length) {
                            playQueue.splice(index, 1);
                            removedCount++;
                            
                            // Adjust current index if needed
                            if (index < currentQueueIndex) {
                                currentQueueIndex--;
                            } else if (index === currentQueueIndex) {
                                // Currently playing video was removed
                                if (playQueue.length > 0) {
                                    // Adjust current index to stay in bounds
                                    currentQueueIndex = Math.min(currentQueueIndex, playQueue.length - 1);
                                    // Play the video at the new current position
                                    if (player) {
                                        playFromQueue(currentQueueIndex);
                                    }
                                } else {
                                    // Queue is empty
                                    clearVideo();
                                }
                            }
                        }
                    });
                    
                    selectedQueueVideos.clear();
                    updateQueueUI();
                    updateQueueSelectedCount();
                    
                    showSuccessMessage(`ğŸ—‘ï¸æˆåŠŸå¾æ’­æ”¾åˆ—è¡¨ç§»é™¤${removedCount}éƒ¨å½±ç‰‡`);
                }
            );
        }

        // Import Queue to Playlist Functions
        function showImportQueueDialog() {
            if (playQueue.length === 0) {
                showCustomAlert('Queue is empty. Add some videos first!', 'info');
                return;
            }
            
            const playlistNames = Object.keys(playlists);
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'importQueueOverlay';
            
            const form = document.createElement('div');
            form.className = 'rename-form';
            // Responsive width handling
            if (window.innerWidth <= 640) {
                form.style.minWidth = 'calc(100vw - 32px)';
                form.style.maxWidth = 'calc(100vw - 32px)';
                form.style.width = 'calc(100vw - 32px)';
            } else {
                form.style.minWidth = '400px';
                form.style.maxWidth = '500px';
                form.style.width = '100%';
            }
            
            form.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">ğŸ“¥ Import Queue to Playlist</h3>
                
                <div class="mb-4 p-3 bg-blue-50 dark:bg-blue-900 rounded-lg">
                    <div class="font-medium text-blue-900 dark:text-blue-100">Current Queue</div>
                    <div class="text-sm text-blue-700 dark:text-blue-300">${playQueue.length} videos</div>
                </div>
                
                <div class="mb-4">
                    <h4 class="font-medium text-gray-700 dark:text-gray-300 mb-2">Choose an option:</h4>
                    
                    <div class="space-y-3">
                        <button 
                            onclick="showCreatePlaylistForQueue()" 
                            class="w-full px-4 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-left flex items-center gap-3"
                        >
                            <span class="text-xl">âœ¨</span>
                            <div>
                                <div class="font-medium">å»ºç«‹æ–°æ’­æ”¾æ¸…å–®</div>
                                <div class="text-sm opacity-90">ä½¿ç”¨é€™${playQueue.length}éƒ¨å½±ç‰‡å»ºç«‹ä¸€å€‹æ–°æ’­æ”¾æ¸…å–®</div>
                            </div>
                        </button>
                        
                        ${playlistNames.length > 0 ? `
                            <button 
                                onclick="showAddToExistingPlaylistDialog()" 
                                class="w-full px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors text-left flex items-center gap-3"
                            >
                                <span class="text-xl">ğŸ“‹</span>
                                <div>
                                    <div class="font-medium">åŠ å…¥è‡³ç¾æœ‰æ’­æ”¾æ¸…å–®</div>
                                    <div class="text-sm opacity-90">å¾${playlistNames.length}å€‹ç¾æœ‰æ’­æ”¾æ¸…å–®ä¸­é¸æ“‡</div>
                                </div>
                            </button>
                        ` : ''}
                    </div>
                </div>
                
                <div class="flex gap-3 justify-end">
                    <button 
                        onclick="hideImportQueueDialog()" 
                        class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
                    >
                        å–æ¶ˆ
                    </button>
                </div>
            `;
            
            overlay.appendChild(form);
            document.body.appendChild(overlay);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hideImportQueueDialog();
                }
            });
        }

        function hideImportQueueDialog() {
            const overlay = document.getElementById('importQueueOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        function showCreatePlaylistForQueue() {
            hideImportQueueDialog();
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'createQueuePlaylistOverlay';
            
            const form = document.createElement('div');
            form.className = 'rename-form';
            
            form.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">âœ¨ Create New Playlist from Queue</h3>
                
                <div class="mb-4">
                    <label class="block font-medium text-gray-700 dark:text-gray-300 mb-2">
                        Playlist Name:
                    </label>
                    <input 
                        type="text" 
                        id="queuePlaylistNameInput" 
                        placeholder="Enter playlist name..."
                        class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:ring-2 focus:ring-primary focus:border-transparent"
                        value="Queue Playlist ${new Date().toLocaleDateString()}"
                    >
                </div>
                
                <div class="mb-4 p-3 bg-gray-50 dark:bg-gray-700 rounded">
                    <div class="text-sm text-gray-600 dark:text-gray-400">
                        This will create a new playlist with all ${playQueue.length} videos from your current queue.
                    </div>
                </div>
                
                <div class="flex gap-3 justify-end">
                    <button 
                        onclick="hideCreateQueuePlaylistDialog()" 
                        class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
                    >
                        å–æ¶ˆ
                    </button>
                    <button 
                        onclick="confirmCreatePlaylistFromQueue()" 
                        class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition-colors"
                    >
                        âœ¨ Create Playlist
                    </button>
                </div>
            `;
            
            overlay.appendChild(form);
            document.body.appendChild(overlay);
            
            // Focus input and select text
            const input = document.getElementById('queuePlaylistNameInput');
            input.focus();
            input.select();
            
            // Handle Enter key
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    confirmCreatePlaylistFromQueue();
                }
            });
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hideCreateQueuePlaylistDialog();
                }
            });
        }

        function hideCreateQueuePlaylistDialog() {
            const overlay = document.getElementById('createQueuePlaylistOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        function confirmCreatePlaylistFromQueue() {
            const input = document.getElementById('queuePlaylistNameInput');
            const name = input.value.trim();
            
            if (!name) {
                showCustomAlert('Please enter a valid playlist name', 'warning');
                return;
            }
            
            if (playlists[name]) {
                showCustomAlert('A playlist with this name already exists', 'warning');
                return;
            }
            
            // Create new playlist with queue videos
            playlists[name] = {
                name: name,
                videos: [...playQueue], // Copy all queue videos
                created: new Date().toISOString(),
                importedFromQueue: true
            };
            
            saveSettings();
            renderPlaylists();
            hideCreateQueuePlaylistDialog();
            
            // Show success message
            showSuccessMessage(`âœ…æˆåŠŸå»ºç«‹ã€Œ${name}ã€ï¼Œå…±${playQueue.length}éƒ¨å½±ç‰‡`);
            
            // Auto-load the new playlist
            setTimeout(() => {
                loadPlaylist(name);
            }, 500);
        }

        function showAddToExistingPlaylistDialog() {
            hideImportQueueDialog();
            
            const playlistNames = Object.keys(playlists);
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'addQueueToPlaylistOverlay';
            
            const form = document.createElement('div');
            form.className = 'rename-form';
            form.style.minWidth = '400px';
            
            form.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">ğŸ“‹ Add Queue to Existing Playlist</h3>
                
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                    Select a playlist to add all ${playQueue.length} videos from your queue:
                </p>
                
                <div class="max-h-64 overflow-y-auto mb-4 space-y-2">
                    ${playlistNames.map(name => `
                        <label class="flex items-center gap-3 p-3 hover:bg-gray-100 dark:hover:bg-gray-600 rounded cursor-pointer border border-gray-200 dark:border-gray-600">
                            <input type="radio" name="targetQueuePlaylist" value="${escapeHtml(name)}" class="queue-playlist-radio">
                            <div class="flex-1">
                                <div class="font-medium">${name}</div>
                                <div class="text-sm text-gray-600 dark:text-gray-400">${playlists[name].videos.length} videos</div>
                            </div>
                        </label>
                    `).join('')}
                </div>
                
                <div class="flex gap-3 justify-end">
                    <button 
                        onclick="hideAddQueueToPlaylistDialog()" 
                        class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
                    >
                        å–æ¶ˆ
                    </button>
                    <button 
                        onclick="confirmAddQueueToPlaylist()" 
                        class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
                    >
                        ğŸ“‹æ·»åŠ è‡³æ’­æ”¾æ¸…å–®
                    </button>
                </div>
            `;
            
            overlay.appendChild(form);
            document.body.appendChild(overlay);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hideAddQueueToPlaylistDialog();
                }
            });
        }

        function hideAddQueueToPlaylistDialog() {
            const overlay = document.getElementById('addQueueToPlaylistOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        function confirmAddQueueToPlaylist() {
            const selectedRadio = document.querySelector('input[name="targetQueuePlaylist"]:checked');
            
            if (!selectedRadio) {
                showCustomAlert('Please select a playlist', 'warning');
                return;
            }
            
            const targetPlaylist = selectedRadio.value;
            
            // Add queue videos to target playlist (filter duplicates)
            const existingIds = new Set(playlists[targetPlaylist].videos.map(v => v.id));
            const newVideos = playQueue.filter(video => !existingIds.has(video.id));
            
            playlists[targetPlaylist].videos.push(...newVideos);
            
            saveSettings();
            renderPlaylists();
            renderCurrentPlaylist();
            hideAddQueueToPlaylistDialog();
            
            if (newVideos.length < playQueue.length) {
                showSuccessMessage(`ğŸ“‹å·²æ·»åŠ ${newVideos.length}éƒ¨å½±ç‰‡è‡³ã€Œ${targetPlaylist}ã€ï¼ˆå·²è·³é${playQueue.length - newVideos.length}éƒ¨é‡è¤‡çš„ï¼‰`);
            } else {
                showSuccessMessage(`ğŸ“‹å·²æ·»åŠ ${newVideos.length}éƒ¨å½±ç‰‡è‡³ã€Œ${targetPlaylist}ã€`);
            }
        }

        // Add Selected Videos from Playlist to Queue Function
        function addSelectedVideosToQueue() {
            if (selectedVideos.size === 0) {
                showCustomAlert('è«‹é¸æ“‡è¦æ–°å¢è‡³åˆ—è¡¨çš„å½±ç‰‡', 'warning');
                return;
            }
            
            if (!currentPlaylist) return;
            
            const currentVideos = playlists[currentPlaylist].videos;
            const videosToAdd = Array.from(selectedVideos).map(index => currentVideos[index]).filter(Boolean);
            
            if (videosToAdd.length === 0) {
                showCustomAlert('æœªé¸æ“‡æœ‰æ•ˆå½±ç‰‡', 'warning');
                return;
            }
            
            // Show options for how to add to queue
            showAddSelectedToQueueDialog(videosToAdd);
        }

        function showAddSelectedToQueueDialog(videos) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'addSelectedToQueueOverlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'play-options-dialog';
            
            dialog.innerHTML = `
                <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">ğŸµæ–°å¢é¸å®šå½±ç‰‡è‡³åˆ—è¡¨</h3>
                
                <div class="mb-4 p-3 bg-gray-50 dark:bg-gray-700 rounded-lg">
                    <div class="font-medium text-sm mb-1">å·²é¸æ“‡${videos.length}éƒ¨å½±ç‰‡</div>
                    <div class="text-xs text-gray-600 dark:text-gray-400">å¾æ’­æ”¾æ¸…å–®ï¼š${currentPlaylist}</div>
                </div>
                
                ${playQueue.length > 0 ? `
                    <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                        æ’­æ”¾åˆ—è¡¨æœ‰${playQueue.length}éƒ¨å½±ç‰‡ï¼Œæ‚¨æƒ³å°‡é€™äº›å½±ç‰‡æ·»åŠ åˆ°å“ªè£¡ï¼Ÿ
                    </p>
                    
                    <div class="space-y-2 mb-6">
                        <button onclick="addMultipleToQueue(${JSON.stringify(videos).replace(/"/g, '&quot;')}, 'current'); hideAddSelectedToQueueDialog()" class="play-option-btn">
                            <div class="play-option-icon">â–¶ï¸</div>
                            <div class="play-option-content">
                                <div class="play-option-title">å–ä»£åˆ—è¡¨ä¸¦æ’­æ”¾</div>
                                <div class="play-option-desc">æ¸…é™¤ç•¶å‰åˆ—è¡¨ä¸¦æ’­æ”¾é€™äº›å½±ç‰‡</div>
                            </div>
                        </button>
                        
                        <button onclick="addMultipleToQueue(${JSON.stringify(videos).replace(/"/g, '&quot;')}, 'next'); hideAddSelectedToQueueDialog()" class="play-option-btn">
                            <div class="play-option-icon">â­ï¸</div>
                            <div class="play-option-content">
                                <div class="play-option-title">æ¥ä¸‹ä¾†æ’­æ”¾</div>
                                <div class="play-option-desc">åœ¨ç•¶å‰å½±ç‰‡ä¹‹å¾Œæ–°å¢æ­¤å½±ç‰‡ï¼ˆåˆ—è¡¨çš„ä¸‹ä¸€å€‹ï¼‰</div>
                            </div>
                        </button>
                        
                        <button onclick="addMultipleToQueue(${JSON.stringify(videos).replace(/"/g, '&quot;')}, 'end'); hideAddSelectedToQueueDialog()" class="play-option-btn">
                            <div class="play-option-icon">ğŸ“</div>
                            <div class="play-option-content">
                                <div class="play-option-title">æ–°å¢åˆ°çµå°¾</div>
                                <div class="play-option-desc">å°‡æ­¤å½±ç‰‡æ–°å¢åˆ°æ’­æ”¾åˆ—è¡¨æœ«å°¾</div>
                            </div>
                        </button>
                    </div>
                ` : `
                    <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                        æ’­æ”¾åˆ—è¡¨æ˜¯ç©ºçš„ï¼Œé€™äº›å½±ç‰‡å°‡è¢«æ·»åŠ ä¸¦é–‹å§‹æ’­æ”¾ã€‚
                    </p>
                    
                    <div class="space-y-2 mb-6">
                        <button onclick="addMultipleToQueue(${JSON.stringify(videos).replace(/"/g, '&quot;')}, 'current'); hideAddSelectedToQueueDialog()" class="play-option-btn">
                            <div class="play-option-icon">â–¶ï¸</div>
                            <div class="play-option-content">
                                <div class="play-option-title">æ·»åŠ è‡³åˆ—è¡¨ä¸¦æ’­æ”¾</div>
                                <div class="play-option-desc">åŠ å…¥é€™${videos.length}éƒ¨å½±ç‰‡ä¸¦é–‹å§‹æ’­æ”¾</div>
                            </div>
                        </button>
                    </div>
                `}
                
                <div class="flex gap-3 justify-end">
                    <button onclick="hideAddSelectedToQueueDialog()" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors">
                        å–æ¶ˆ
                    </button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hideAddSelectedToQueueDialog();
                }
            });
        }

        function hideAddSelectedToQueueDialog() {
            const overlay = document.getElementById('addSelectedToQueueOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        function addMultipleToQueue(videos, position = 'end') {
            if (!Array.isArray(videos) || videos.length === 0) return;
            
            // Filter out duplicates
            const existingIds = new Set(playQueue.map(v => v.id));
            const newVideos = videos.filter(video => !existingIds.has(video.id));
            
            if (newVideos.length === 0) {
                showSuccessMessage('ğŸµæ‰€æœ‰é¸å®šçš„å½±ç‰‡éƒ½å·²åœ¨æ’­æ”¾åˆ—è¡¨ä¸­');
                return;
            }
            
            // Add videos based on position
            switch (position) {
                case 'next':
                    // Add after current video
                    playQueue.splice(currentQueueIndex + 1, 0, ...newVideos);
                    break;
                case 'current':
                    // Replace entire queue
                    playQueue = [...newVideos];
                    currentQueueIndex = 0;
                    playFromQueue(0);
                    break;
                default: // 'end'
                    playQueue.push(...newVideos);
                    break;
            }
            
            updateQueueUI();
            
            // Clear selection in playlist
            selectedVideos.clear();
            updateSelectedCount();
            
            // Show success message
            const positionText = position === 'next' ? 'æ’­æ”¾åˆ—è¡¨çš„ä¸‹ä¸€å€‹' : position === 'current' ? 'æ’­æ”¾åˆ—è¡¨ï¼ˆç¾åœ¨æ’­æ”¾ï¼‰' : 'æ’­æ”¾åˆ—è¡¨æœ«å°¾';
            const duplicateMsg = newVideos.length < videos.length ? `ï¼ˆå·²è·³é${videos.length - newVideos.length}éƒ¨é‡è¤‡çš„ï¼‰` : '';
            showSuccessMessage(`ğŸµå·²æ·»åŠ ${newVideos.length}éƒ¨å½±ç‰‡è‡³${positionText}${duplicateMsg}`);
        }

        // Custom Modal Dialog Functions (replacing alert/confirm)
        function showCustomAlert(message, type = 'info') {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'customAlertOverlay';
            
            const iconMap = {
                'info': 'ğŸ“‹',
                'warning': 'âš ï¸',
                'success': 'âœ…',
                'error': 'âŒ'
            };
            
            const colorMap = {
                'info': 'bg-blue-600',
                'warning': 'bg-yellow-600',
                'success': 'bg-green-600',
                'error': 'bg-red-600'
            };
            
            const modal = document.createElement('div');
            modal.className = 'rename-form';
            modal.style.minWidth = '300px';
            modal.style.maxWidth = '400px';
            
            modal.innerHTML = `
                <div class="flex items-center gap-3 mb-4">
                    <span class="text-2xl">${iconMap[type]}</span>
                    <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Information</h3>
                </div>
                
                <p class="text-gray-700 dark:text-gray-300 mb-6">${message}</p>
                
                <div class="flex justify-end">
                    <button 
                        onclick="hideCustomAlert()" 
                        class="px-6 py-2 ${colorMap[type]} text-white rounded hover:opacity-90 transition-colors"
                    >
                        ç¢ºå®š
                    </button>
                </div>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // Auto-focus the OK button
            setTimeout(() => {
                const okButton = modal.querySelector('button');
                okButton.focus();
            }, 100);
            
            // Handle keyboard shortcuts
            const handleKeyDown = (e) => {
                if (e.key === 'Enter' || e.key === 'Escape') {
                    hideCustomAlert();
                }
            };
            document.addEventListener('keydown', handleKeyDown);
            
            // Store the cleanup function
            overlay.cleanup = () => {
                document.removeEventListener('keydown', handleKeyDown);
            };
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hideCustomAlert();
                }
            });
        }

        function hideCustomAlert() {
            const overlay = document.getElementById('customAlertOverlay');
            if (overlay) {
                if (overlay.cleanup) overlay.cleanup();
                overlay.remove();
            }
        }

        function showCustomConfirm(message, onConfirm, onCancel = null) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'customConfirmOverlay';
            
            const modal = document.createElement('div');
            modal.className = 'rename-form';
            modal.style.minWidth = '350px';
            modal.style.maxWidth = '450px';
            
            modal.innerHTML = `
                <div class="flex items-center gap-3 mb-4">
                    <span class="text-2xl">â“</span>
                    <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Confirm Action</h3>
                </div>
                
                <p class="text-gray-700 dark:text-gray-300 mb-6">${message}</p>
                
                <div class="flex justify-end gap-3">
                    <button 
                        onclick="hideCustomConfirm(false)" 
                        class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
                    >
                        å–æ¶ˆ
                    </button>
                    <button 
                        onclick="hideCustomConfirm(true)" 
                        class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors"
                        id="confirmButton"
                    >
                        Confirm
                    </button>
                </div>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // Store callbacks
            overlay.onConfirm = onConfirm;
            overlay.onCancel = onCancel;
            
            // Auto-focus the confirm button
            setTimeout(() => {
                const confirmButton = document.getElementById('confirmButton');
                confirmButton.focus();
            }, 100);
            
            // Handle keyboard shortcuts
            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    hideCustomConfirm(true);
                } else if (e.key === 'Escape') {
                    hideCustomConfirm(false);
                }
            };
            document.addEventListener('keydown', handleKeyDown);
            
            // Store the cleanup function
            overlay.cleanup = () => {
                document.removeEventListener('keydown', handleKeyDown);
            };
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    hideCustomConfirm(false);
                }
            });
        }

        function hideCustomConfirm(confirmed = false) {
            const overlay = document.getElementById('customConfirmOverlay');
            if (overlay) {
                if (overlay.cleanup) overlay.cleanup();
                
                // Execute appropriate callback
                if (confirmed && overlay.onConfirm) {
                    overlay.onConfirm();
                } else if (!confirmed && overlay.onCancel) {
                    overlay.onCancel();
                }
                
                overlay.remove();
            }
        }
    </script>
</body>
</html>
